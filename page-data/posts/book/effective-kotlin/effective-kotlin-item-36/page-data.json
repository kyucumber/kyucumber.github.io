{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-36","result":{"data":{"markdownRemark":{"id":"182755ed-45b7-53e3-ace2-4625f3849d8e","html":"<p>상속은 관계가 명확하지 않을 때 사용하면 여러 문제가 발생할 수 있다.\n단순하게 코드 추출 또는 재사용을 위해 상속을 하는건 지양해야 한다.</p>\n<p>일반적으로 아래와 같은 경우 상속보다는 컴포지션을 사용하는게 좋다.</p>\n<ul>\n<li>간단한 행위 재사용</li>\n<li>모든것을 가져올 수 밖에 없는 상속</li>\n<li>캡슐화를 깨는 상속</li>\n</ul>\n<h2 id=\"간단한-행위-재사용\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%96%89%EC%9C%84-%EC%9E%AC%EC%82%AC%EC%9A%A9\" aria-label=\"간단한 행위 재사용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 행위 재사용</h2>\n<p>아래와 같이 프로그레스 바를 어떤 로직 처리 전에 출력하고 처리후에 숨기는\n유사한 동작을 하는 두개의 클래스가 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class ProfileLoader {\n    fun load() {\n        // 프로그레스 바를 보여 줌\n        // 프로파일을 읽어 들임 *\n        // 프로그레스 바를 숨김\n    }\n}\n\nclass ImageLoader {\n    fun load() {\n        // 프로그레스 바를 보여 줌\n        // 이미지를 읽어 들임 *\n        // 프로그레스 바를 숨김\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같은 경우 많은 개발자는 상속을 통해 공통되는 행위를 추출한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">abstract class LoaderWithProgress {\n    fun load() {\n        // 프로그레스 바를 보여 줌\n        innerLoad()\n        // 프로그레스 바를 숨김\n    }\n    \n    abstract fun innerLoad()\n}\n\nclass ProfileLoader : LoaderWithProgress() {\n    override fun innerLoad() {\n        // 프로파일을 읽어 들임\n    }\n}\n\nclass ImageLoader : LoaderWithProgress() {\n    override fun innerLoad() {\n        // 이미지를 읽어 들임\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이는 간단한 경우 문제없이 동작하지만 몇가지 단점이 있다.</p>\n<ul>\n<li>\n<p>상속을 사용해 행위를 추출하다 보면 굉장히 깊고 복잡한 계층 구조가 만들어진다.</p>\n<ul>\n<li>상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해 행위를 추출하다 보면 거대한 BaseXXX 클래스를 만들게 되고 굉장히 깊고 복잡한 계층 구조가 만들어진다.</li>\n</ul>\n</li>\n<li>\n<p>인터페이스 분리 원칙(Interface Segregation Principle) 위반</p>\n<ul>\n<li>상속은 클래스의 모든것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어질 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>상속은 이해하기 어렵다.</p>\n<ul>\n<li>일반적으로 개발자가 메소드를 읽고 메소드의 장독 방식을 이해하기 위해 슈퍼클래스를 여러번 확인해야 한다면, 문제가 있는 것이다.</li>\n</ul>\n</li>\n</ul>\n<p>이러한 이유 때문에 다른 대안을 사용하는것이 좋다.\n대표적인 대안은 바로 <strong>컴포지션(composition)</strong>이다.</p>\n<p>컴포지션을 사용한다는 것은 객체를 프로퍼티로 갖고,\n함수를 호출하는 형태로 재사용하는 것을 의미한다.\n컴포지션을 사용해 문제를 해결하면 아래와 같은 코드를 사용한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class Progress {\n    fun showProgress() {}\n    fun hideProgress() {}\n}\n\nclass ProfileLoader {\n    private val progress = Progress()\n    \n    fun load() {\n        progress.showProgress()\n        // 프로파일을 읽어 들임\n        progress.hideProgress()\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>추가 코드를 적절하게 처리하는것이 조금 어려울 수 있어\n컴포지션보다 상속을 선호하는 경우도 있다. </p>\n<p>컴포지션을 사용하면 다음과 같은 장점이 있다.</p>\n<ul>\n<li>추가 코드로 인해 코드를 읽는 사람들이 코드의 실행을 더 명확하게 예측할 수 있다.</li>\n<li>\n<p>하나의 클래스 내부에서 여러 기능을 재사용할 수 있다.</p>\n<p>이미지를 읽어들이고 나서 경고창을 출력하고 싶다면 아래와 같이 컴포지션을 활용할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class ImageLoader {\n    private val progress = Progress()\n    private val finishedAlert = FinishedAlert()\n\n    fun load() {\n        progress.showProgress()\n        // 이미지를 읽어 들임\n        progress.hideProgress()\n        finishedAlert.show()\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같은 기능을 상속을 통해 구현하려면? 하나 이상의 클래스를 상속할 수 없으므로\n상속으로 이를 구현하려면 두 기능을 하나의 슈퍼클래스에 배치해야 한다.</p>\n<p>이 때문에 클래스들에 복잡한 계층 구조가 만들어질 수 있다.\n예를 들어 3개의 슈퍼클래스가 프로그레스바와 경고창을 만드는 슈퍼클래스를 상속받는데 1개의 서브클래스에서는 경고창이 필요없을때 아래와 같이 파라미터가 있는 생성자를 사용해야 한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">abstract class InternetLoader(val showAlert: Boolean) {\n    fun load() {\n        // 프로그레스 바를 보여줌\n        innerLoad()\n        // 프로그레스 바를 숨김\n        if (showAlert) {\n            // 경고창 출력\n        }\n    }\n    abstract class innerLoad() {}\n}\n\nclass ProfileLoader : InternetLoader(showAlert = true) {\n    override fun innerLoad() {\n        // 프로파일을 읽어 들임\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이것은 굉장히 나쁜 해결 방법이다. 서브클래스가 필요하지도 않은 기능을 갖고 단순하게 이를 차단하고 있다. 기능을 제대로 차단하지 못하면 문제가 발생할 수 있다.</p>\n</li>\n</ul>\n<h2 id=\"모든것을-가져올-수-밖에-없는-상속\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EA%B0%80%EC%A0%B8%EC%98%AC-%EC%88%98-%EB%B0%96%EC%97%90-%EC%97%86%EB%8A%94-%EC%83%81%EC%86%8D\" aria-label=\"모든것을 가져올 수 밖에 없는 상속 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모든것을 가져올 수 밖에 없는 상속</h2>\n<p>상속은 슈퍼클래스의 모든 것을 가져온다. 일부분을 재사용하고 싶다면 컴포지션을 사용하는게 좋다.</p>\n<p>bark(짖기) sniff(냄새 맡기)라는 함수를 갖는 Dog 클래스가 있을 때</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">abstract class Dog {\n    open fun bark() {}\n    open fun sniff() {}\n}</code>\n        </deckgo-highlight-code>\n<p>로봇 강아지는 bark(짖기)만 가능하고 sniff(냄새 맡기)는 못하게 하려는 요구사항이 있을 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class RobotDog : Dog() {\n    override fun sniff() {\n        throw Error(&quot;Operation not suppoerted&quot;)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>RobotDog는 아래와 같이 필요도 없는 메소드를 갖게 되며 아래와 같은 문제를 가진다.</p>\n<ul>\n<li>인터페이스 분리 원칙 위반</li>\n<li>슈퍼클래스의 동작을 서브클래스에서 깨버리므로 리스코프 치환 원칙 위반</li>\n</ul>\n<p>컴포지션을 사용하면 위와 같은 문제가 발생하지 않는다.</p>\n<p>무조건 컴포지션을 사용해야 하는 것은 아니며, 타입 계층 구조를 표현해야 한다면 인터페이스를 활용해 다중 상속을 하는 것이 좋을 수도 있다.</p>\n<h2 id=\"캡슐화를-깨는-상속\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94%EB%A5%BC-%EA%B9%A8%EB%8A%94-%EC%83%81%EC%86%8D\" aria-label=\"캡슐화를 깨는 상속 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화를 깨는 상속</h2>\n<p>상속을 활용할 때 내부적인 구현 방법에 의해 클래스의 캡슐화가 깨질 수 있다.</p>\n<p>아래 HasSet을 상속한 CounterSet 클래스는 문제가 없어 보인다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class CounterSet&lt;T&gt; : HashSet&lt;T&gt;() {\n    var elementsAdded: Int = 0\n    private set\n    \n    override fun add(element: T): Boolean {\n        elementsAdded++\n        return super.add(element)\n    }\n    \n    override fun addAll(elements: Collection&lt;T&gt;): Boolean {\n        elementsAdded += elements.size\n        return super.addAll(elements)\n    }\n}\n\nval counterList = CounterSet&lt;String&gt;()\ncounterList.addAll(listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;))\nprint(counterList.elementsAdded) // 3이 아닌 6이 출력된다.</code>\n        </deckgo-highlight-code>\n<p>위에서는 의도한 3이 출력되지 않는다. 이는 HashSet의 addAll 내부에서 add를 사용하기 때문이다.</p>\n<p>여기서는 아래와 같이 addAll을 제거하면 문제가 사라진다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class CounterSet&lt;T&gt; : HashSet&lt;T&gt;() {\n    var elementsAdded: Int = 0\n    private set\n\n    override fun add(element: T): Boolean {\n        elementsAdded++\n        return super.add(element)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 이후 자바가 HashSet.addAll을 최적화하고 add를\n호출하지 않는 방식으로 구현된다면 예상하지 못한 형태로 동작할 수 있다.</p>\n<p>위처럼 라이브러리의 구현이 변경되는 일은 꽤 자주 접할 수 있는 문제이며 상속 대신 컴포지션을 사용해 문제가 발생할 가능성을 막을 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class CounterSet&lt;T&gt; {\n    private val innerSet = HashSet&lt;T&gt;()\n    \n    var elementsAdded: Int = 0\n    private set\n\n    fun add(element: T) {\n        elementsAdded++\n        innerSet.add(element)\n    }\n    \n    fun addAll(elements: Collection&lt;T&gt;) {\n        elementsAdded += elements.size\n        innerSet.addAll(elements)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 수정하는 경우 다형성이 사라진다는 문제가 있으며 이는 위임 패턴을 사용해 해결할 수 있다.</p>\n<p>위임 패턴은 클래스가 인터페이스를 상속받게 하고 포함한 객체의 메소드를 활용해 인터페이스에서 정의한 메소드를 구현하는 패턴이다.</p>\n<p>이렇게 구현된 메소드를 포워딩 메소드(forwarding method)라고 부르며 코드로 살펴보면 다음과 같다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class CounterSet&lt;T&gt; : MutableSet&lt;T&gt;{\n    private val innerSet = HashSet&lt;T&gt;()\n  \n    var elementsAdded: Int = 0\n        private set\n\n    override fun add(element: T): Boolean {\n        elementsAdded++\n        return innerSet.add(element)\n    }\n    \n    override fun addAll(elements: Collection&lt;T&gt;): Boolean {\n        elementsAdded += elements.size\n        return innerSet.addAll(elements)\n    }\n   \n    override val size: Int\n        get() = innerSet.size\n\n    // 길어서 생략, 대략 6개의 포워딩 메소드를 더 만들어야 한다\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 만들면 포워딩 메소드가 너무 많아진다. (위 예제에서는 9개를 구현해야 한다.)</p>\n<p>하지만 코틀린에서는 아래와 같이 위임 패턴을 쉽게 사용할 수 있는 문법을 제공한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class CounterSet&lt;T&gt;(\n    private val innerSet: MutableSet&lt;T&gt; = mutableSetOf()\n) : MutableSet&lt;T&gt; by innerSet {\n    var elementsAdded: Int = 0\n        private set\n\n    fun add(element: T): Boolean {\n        elementsAdded++\n        return innerSet.add(element)\n    }\n    \n    fun addAll(elements: Collection&lt;T&gt;): Boolean {\n        elementsAdded += elements.size\n        return innerSet.addAll(elements)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위처럼 다형성이 필요한데 상속된 메소드를 직접 활용하는게 위험할 때는 위와 같이 위임 패턴을 사용하는게 좋다.</p>\n<h2 id=\"오버라이딩-제한\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%A0%9C%ED%95%9C\" aria-label=\"오버라이딩 제한 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오버라이딩 제한</h2>\n<p>개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면 final을 사용하면 된다.</p>\n<p>만약 어떤 이유로 상속은 허용하지만 메소드는 오버라이드하지 못하게 하고 싶은 경우가 있을 수 있다.</p>\n<p>이 경우 클래스에 open 키워드를 사용하면 된다. open 클래스는 open 메소드만 오버라이드 할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">open class Parent {\n    fun a() {}\n    open fun b() {}\n}\n\nclass Child: Parent() {\n    override fun a() {} // 오류\n    override fun b() {}\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>컴포지션과 상속은 다음과 같은 차이가 있다.</p>\n<ul>\n<li>컴포지션은 안전하다. 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존하므로 안전하다.</li>\n<li>\n<p>컴포지션은 더 유연하다.</p>\n<ul>\n<li>상속은 한 클래스만을 대상으로 할 수 있지만 컴포지션은 여러 클래스를 대상으로 할 수 있다.</li>\n<li>상속은 모든 것을 받지만 컴포지션은 필요한 것만 받을 수 있다.</li>\n<li>슈퍼클래스의 동작을 변경하면 서브클래스의 동작도 큰 영향을 받지만 컴포지션은 이러한 영향이 제한적이다.</li>\n</ul>\n</li>\n<li>\n<p>컴포지션은 더 명시적이다.</p>\n<ul>\n<li>슈퍼클래스의 메소드를 사용할때는 리시버를 지정하지 않아도 된다.</li>\n<li>컴포지션을 사용하면 리시버를 명시적으로 활용해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>컴포지션은 생각보다 번거롭다.</p>\n<ul>\n<li>객체를 명시적으로 사용해야 하므로 대상 클래스에 일부 기능을 추가할 때 이를 포함하는 객체의 코드를 변경해야 한다. 그래서 상속을 사용할 때 보다 코드를 수정해야 하는 경우가 많다.</li>\n</ul>\n</li>\n<li>상속은 다형성을 활용할 수 있다.</li>\n</ul>\n<p>일반적으로 OOP에서는 상속보다 컴포지션을 사용하는것이 좋다. 상속은 is-a 관계가 명확할 때 상속을 사용하는 것이 좋다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%96%89%EC%9C%84-%EC%9E%AC%EC%82%AC%EC%9A%A9\">간단한 행위 재사용</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#%EB%AA%A8%EB%93%A0%EA%B2%83%EC%9D%84-%EA%B0%80%EC%A0%B8%EC%98%AC-%EC%88%98-%EB%B0%96%EC%97%90-%EC%97%86%EB%8A%94-%EC%83%81%EC%86%8D\">모든것을 가져올 수 밖에 없는 상속</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#%EC%BA%A1%EC%8A%90%ED%99%94%EB%A5%BC-%EA%B9%A8%EB%8A%94-%EC%83%81%EC%86%8D\">캡슐화를 깨는 상속</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%A0%9C%ED%95%9C\">오버라이딩 제한</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-36/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-36","tagSlugs":null},"frontmatter":{"date":"2022-03-12T00:00:00.000Z","description":"Effective Kotlin Item 36. 상속보다는 컴포지션을 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 36. 상속보다는 컴포지션을 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-36"}},"staticQueryHashes":["2067870509","251939775","401334301"]}