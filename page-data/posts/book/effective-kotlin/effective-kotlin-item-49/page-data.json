{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-49","result":{"data":{"markdownRemark":{"id":"b68da602-4be5-5929-a913-8ede32477640","html":"<p>Iterable과 Sequence의 코드는 동일하지만 둘은 완전 다른 목적으로 설계되었다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">interface Iterable&lt;out T&gt; {\n    operator fun iterator(): Iterator&lt;T&gt;\n}\n\ninterface Sequence&lt;out T&gt; {\n    operator fun iterator(): Iterator&lt;T&gt;\n}</code>\n        </deckgo-highlight-code>\n<p>Sequence는 지연(lazy)로 처리된다. 따라서 시퀀스 처리 함수들을 사용하면, 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다. 최종적인 계산은 toList 또는 count 등의 최종 연산이 이루어질때 수행된다.</p>\n<p>Iterable은 처리 함수를 사용할 때 마다 연산이 이루어져 List가 만들어진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 816px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6f9c50dea2c9e9b03dfdc5344e87d17c/b4098/item49_01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAAAuklEQVQoz4VR7Q6DIAzk/V9w2985BZ2IX4io8UabzRhn8BJSoOV6RwW+WNd1i/v9Hr9cbIlYktB1LZRSMMb8NTmrF4hgnmcm7Psezjk+HwmODkRdG6TpC0WRQ8oMbdtwzLIUTV0HkgmT9yjLNx73W1CbwfsR1lpUlea6JHnyG1bIlqSE1mVYOqjpUL4LbjIMFuPoOFKO7oiY1FIdiVFKMiEJurR8NpgjlmVh8s3y1dRi0yXkuWKF9M+ED4tuI0w/kkWMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/6f9c50dea2c9e9b03dfdc5344e87d17c/8ac56/item49_01.webp 240w,\n/static/6f9c50dea2c9e9b03dfdc5344e87d17c/d3be9/item49_01.webp 480w,\n/static/6f9c50dea2c9e9b03dfdc5344e87d17c/79303/item49_01.webp 816w\"\n          sizes=\"(max-width: 816px) 100vw, 816px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/6f9c50dea2c9e9b03dfdc5344e87d17c/8ff5a/item49_01.png 240w,\n/static/6f9c50dea2c9e9b03dfdc5344e87d17c/e85cb/item49_01.png 480w,\n/static/6f9c50dea2c9e9b03dfdc5344e87d17c/b4098/item49_01.png 816w\"\n          sizes=\"(max-width: 816px) 100vw, 816px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/6f9c50dea2c9e9b03dfdc5344e87d17c/b4098/item49_01.png\"\n          alt=\"Untitled\"\n          title=\"Untitled\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<p>이와 같은 시퀀스의 지연 처리는 다음과 같은 장점을 갖는다.</p>\n<ul>\n<li>자연스러운 처리 순서를 유지한다.</li>\n<li>최소한만 연산한다.</li>\n<li>무한 시퀀스 형태로 사용할 수 있다.</li>\n<li>각각의 단계에서 컬렉션을 만들어내지 않는다.</li>\n</ul>\n<h2 id=\"순서의-중요성\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%84%9C%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1\" aria-label=\"순서의 중요성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순서의 중요성</h2>\n<ul>\n<li>\n<p>element-by-element order(lazy order)</p>\n<p>시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">sequenceOf(1, 2, 3)\n    .filter { print(&quot;F$it, &quot;); it % 2 == 1 }\n    .map { print(&quot;M$it, &quot;); it * 2 }\n    .forEach { print(&quot;E$it, &quot;) }\n// F1, M1, E2, F2, F3, M3, E6, </code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>step-by-step order(eager order)</p>\n<p>반면 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해 나간다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">listOf(1,2,3)\n        .filter { print(&quot;F$it, &quot;); it % 2 == 1 }\n        .map { print(&quot;M$it, &quot;); it * 2 }\n        .forEach { print(&quot;E$it, &quot;) }\n// F1, F2, F3, M1, M3, E2, E6,</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 915px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ef952e29f609a29954bdf75491908547/4255a/item49_02.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABAUlEQVQoz31S2Q6DQAj0/3+y7VNP67G3uyt1oKhp2pKQRY5hABv6I6UUynla35wzK0S/p2l7ay3UzPO8cyZ+AQB/CIGcs8vryXu/2hDY3juy1lKMkYahZ5wPQGGzAQqItYYLnHMMDAEQ7K57vuODAJaSKaXEQYACSGVjGGgcRwaMMXAOAPcTGDNyPTPUMbEDYSh7QjGYqcBWhsYYVpW2bSnryOgEulDp6jgpLTuFzaxnYYx9oSlsKGK1Vs7DDZpfF0YiViFFtF4W48EPYMRUlAwz/KWyR0+Px50ulzMvH34wVJDT8UC323XNb74x2wMCpO/7RbvlMAOPpzH9XXAQbfICZdfB4cJSTXoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/ef952e29f609a29954bdf75491908547/8ac56/item49_02.webp 240w,\n/static/ef952e29f609a29954bdf75491908547/d3be9/item49_02.webp 480w,\n/static/ef952e29f609a29954bdf75491908547/632b0/item49_02.webp 915w\"\n          sizes=\"(max-width: 915px) 100vw, 915px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/ef952e29f609a29954bdf75491908547/8ff5a/item49_02.png 240w,\n/static/ef952e29f609a29954bdf75491908547/e85cb/item49_02.png 480w,\n/static/ef952e29f609a29954bdf75491908547/4255a/item49_02.png 915w\"\n          sizes=\"(max-width: 915px) 100vw, 915px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/ef952e29f609a29954bdf75491908547/4255a/item49_02.png\"\n          alt=\"Untitled\"\n          title=\"Untitled\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<p>반복문과 조건을 사용해 처리하면 시퀀스 처리인 element-by-element order와 같은 동작을 한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">for (e in listOf(1,2,3)) {\n    print(&quot;F$e, &quot;)\n    if (e % 2 == 1) {\n        print(&quot;M$e, &quot;)\n        val mapped = e * 2\n        print(&quot;E$mapped, &quot;)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>따라서 시퀀스 처리에 사용되는 element-by-element order가 훨씬 자연스러운 처리라고 할 수 있다.</p>\n<p>또한 기본 반복문, 조건문을 사용한 코드와 같으므로 조만간 낮은 레벨 컴파일러 최적화를 통해 더 빨라질 수도 있다.</p>\n<h2 id=\"최소-연산\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%86%8C-%EC%97%B0%EC%82%B0\" aria-label=\"최소 연산 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최소 연산</h2>\n<p>컬렉션에 어떤 처리를 적용하고 나서 앞의 요소 10개만 필요한 상황은 굉장히 자주 접할 수 있는 상황이다.</p>\n<ul>\n<li>\n<p>Iterable</p>\n<ul>\n<li>중간 연산이라는 개념이 없어 원하는 처리를 컬렉션 전체에 적용한 뒤 앞의 요소 10개만 사용해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>Sequence</p>\n<ul>\n<li>중간 연산 개념이 있어 앞의 요소 10개에만 원하는 처리를 적용할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 865px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/976f094495d8e45f3d0dd683c2aea554/79e48/item49_03.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.416666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAABPElEQVQoz3VT2baDIAz0///wVu1T667UBXHPZWijuOWcHJBMkhmIDtFCy7I5m3125Vc4mGMHYUII48cE3rN1XUdVVZ1wDn/M82wCaZpSFIU/0LxLgDGuaRqKo+jE2BQcx5GSJKY4jnTBhPI8055TEASkVLsmAMdxNMUejj0a7BhCQt/31LatdknDMOgzZRjBEcOKeN93JGVjmiFPKUXTNG0MbclfQLuTCWZZlhoMmAxDr9eajrYyRHfxEVr2JgFrGAY06BgbCn80jmUzid0rMxAS8Gp1Xf3WmsqyNNLtB5FSUq3jYGi//u3YTNNoZNsGBVmWrXeJHNzbcZRWyej6fPpGqhDFesE2M5yhiOv+0fv9oqIorhnyTHnug3zfs2bwDEZBz3vo5l/c7R3yAEMO7uzuD+ECGBuM1tWv9w815aur+yQ3+wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/976f094495d8e45f3d0dd683c2aea554/8ac56/item49_03.webp 240w,\n/static/976f094495d8e45f3d0dd683c2aea554/d3be9/item49_03.webp 480w,\n/static/976f094495d8e45f3d0dd683c2aea554/5d624/item49_03.webp 865w\"\n          sizes=\"(max-width: 865px) 100vw, 865px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/976f094495d8e45f3d0dd683c2aea554/8ff5a/item49_03.png 240w,\n/static/976f094495d8e45f3d0dd683c2aea554/e85cb/item49_03.png 480w,\n/static/976f094495d8e45f3d0dd683c2aea554/79e48/item49_03.png 865w\"\n          sizes=\"(max-width: 865px) 100vw, 865px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/976f094495d8e45f3d0dd683c2aea554/79e48/item49_03.png\"\n          alt=\"Untitled\"\n          title=\"Untitled\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<p>이러한 이유로 중간 처리 단계를 모든 요소에 적용할 필요가 없는 경우 시퀀스를 사용하는게 좋다.</p>\n<h2 id=\"무한-시퀀스\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%ED%95%9C-%EC%8B%9C%ED%80%80%EC%8A%A4\" aria-label=\"무한 시퀀스 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무한 시퀀스</h2>\n<p>시퀀스는 최종 연산이 일어나기 전까지는 어떠한 처리도 하지 않는다. 따라서 무한 시퀀스(infinite sequence)를 만들고 필요한 부분까지만 값을 추출하는 것도 가능하다.</p>\n<p>무한 시퀀스를 만들기 위해 일반적으로 generateSequence 또는 sequence를 사용할 수 있다.</p>\n<ul>\n<li>\n<p>generateSequence</p>\n<p>첫번째 요소와 그 다음 요소를 계산하는 방법을 지정해야 한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">generateSequence(1) { it + 1 }\n        .map { it * 2 }\n        .take(10)\n        .forEach { print(&quot;$it, &quot;) }\n// 2, 4, 6, 8, 10, 12, 14, 16, 18 ,20</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>sequence</p>\n<p>중단 함수(suspending function, sequential 코루틴)으로 요소들을 지정한다.\n시퀀스 빌더는 중단 함수 내부에서 yield로 값을 하나씩 만들어 낸다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">val fibonacci = sequence {\n  yield(1)\n  val current = 1\n  var prev = 1\n  while (true) {\n      yield(current)\n      val temp = prev\n      prev = current\n      current += temp\n  }\n}\nprint(fibonacci.take(10).toList())\n// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>무한 시퀀스 사용 시 값을 몇개 활용할지 지정해야 한다.</p>\n<p>take를 사용해 활용할 값의 수를 지정하거나 first, find, any, all, none, indexOf와 같은 일부 요소만 선택하는 종결 연산을 활용해야 한다.</p>\n<p>종결 연산을 잘못 활용하면 아래처럼 무한 반복에 빠지는 경우가 많다.</p>\n<ul>\n<li>any에서 true를 리턴하지 못하는 경우</li>\n<li>all, none에서 false를 리턴하지 못하는 경우</li>\n</ul>\n<p>무한 시퀀스는 종결 연산으로 take, first 정도만 사용하는 것이 좋다.</p>\n<h2 id=\"각각의-단계에서-컬렉션을-만들어-내지-않음\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%98-%EB%8B%A8%EA%B3%84%EC%97%90%EC%84%9C-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%82%B4%EC%A7%80-%EC%95%8A%EC%9D%8C\" aria-label=\"각각의 단계에서 컬렉션을 만들어 내지 않음 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각각의 단계에서 컬렉션을 만들어 내지 않음</h2>\n<p>표준 컬렉션 처리 함수는 각각의 단계에서 새로운 컬렉션(대부분 List)을 만들어낸다. 각각의 단계에서 결과가 만들어지면서 <strong>공간을 차지하는 비용이 든다는 것은 큰 단점</strong>이다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">numbers\n    .filter { it % 10 == 0 } // 여기서 컬렉션 하나\n    .map { it * 2 } // 여기에서 컬렉션 하나\n    .sum()\n\n// 총 2개 컬렉션 생성\n\nnumbers\n    .asSequence()\n    .filter { it % 10 == 0 }\n    .map { it * 2 }\n    .sum()\n// 시퀀스를 사용하면 컬렉션이 만들어지지 않음</code>\n        </deckgo-highlight-code>\n<p>무거운 컬렉션을 처리할때는 위에서 말한 비용은 굉장히 커진다. 극단적인 예이지만 기가바이트 단위의 파일을 읽고 컬렉션 처리를 하면 엄청난 메모리 낭비가 발생한다.</p>\n<p>따라서 일반적으로 파일을 처리할 때는 시퀀스를 활용한다.</p>\n<p>아래처럼 1.53GB 정도의 데이터를 처리하는 경우</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">File(&quot;ChicagoCrimes.csv&quot;).readLines()\n    .drop(1)\n    .mapNotNull { it.split(&quot;,&quot;).getOrNull(6) }\n    .filter { &quot;CANNABIS&quot; in it }\n    .count()\n    .let(::println)</code>\n        </deckgo-highlight-code>\n<p>컬렉션을 추가로 만드는 중간 연산이 3번이나 일어나며 대충 어림잡아도 4.59(1..53 x 3)GB의 메모리를 소비한다. 이를 시퀀스로 만드는 경우 이러한 낭비를 줄일 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">File(&quot;ChicagoCrimes.csv&quot;).useLines { lines -&gt;\n    lines.\n        .drop(1)\n        .mapNotNull { it.split(&quot;,&quot;).getOrNull(6) }\n        .filter { &quot;CANNABIS&quot; in it }\n        .count()\n        .let { println(it) }\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>useLines를 사용하면 Suquence<String> 형태로 파일을 사용할 수 있다.</p>\n</blockquote>\n<p>큰 컬렉션으로 여러 처리 단계를 거쳐야 한다면 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋다.</p>\n<p>책에서는 2-3개의 처리 단계를 가지는 함수를 비교하는데 아래와 같은 결과가 나온다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">twoStepListProcessing                  81.095 ns\ntwoStepSequenceProcessing              55.68 ns\n\ntwoStepListProcessingAndAcumulate      83.307 ns\ntwoStepSequenceProcessingAndAcumulate  6.928 ns</code>\n        </deckgo-highlight-code>\n<p>책에서는 하나 이상의 처리 단계를 포함하는 경우 시퀀스 사용시 컬렉션 처리 대비 20~40%정도의 성능 향상을 보았다고 한다.</p>\n<h2 id=\"시퀀스가-빠르지-않은-경우\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%80%80%EC%8A%A4%EA%B0%80-%EB%B9%A0%EB%A5%B4%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0\" aria-label=\"시퀀스가 빠르지 않은 경우 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시퀀스가 빠르지 않은 경우</h2>\n<p>컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않는다.</p>\n<p>코틀린 stdlib의 sorted가 그런 예 중 하나이다. sorted는 Sequence를 List로 변환한 다음에 stdlib의 sort를 이용해 처리하며 이런 변환으로 인해 시퀀스가 컬렉션 처리보다 느려진다. (큰 차이는 아니다.)</p>\n<p>무한 시퀀스처럼 시퀀스의 다음 요소를 lazy하게 구하는 시퀀스에 sorted를 적용하면 무한 반복에 빠진다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">generateSequence(0) { it + 1 }.take(10).sorted().toList()\n// 정상 동작\ngenerateSequence(0) { it + 1 }.sorted().take(10).toList()\n// 무한 반복</code>\n        </deckgo-highlight-code>\n<p>sorted는 시퀀스보다 컬렉션이 더 빠른 희귀한 예 중 하나이다. 다른 처리는 모두 시퀀스가 빠르기 때문에 여러 처리가 결합된 경우라면 sorted가 포함되어 있더라도 시퀀스를 사용하는것이 더 빠르다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// 벤치마크 150.48s ns\nfun productsSortAndProcessingList(): Double {\n    return productsList\n            .sortedBy { it.price }\n            .filter { it.bought }\n            .map { it.price }\n            .average()\n}\n\n// 벤치마크 96.811s ns\nfun productsSortAndProcessingSequence(): Double {\n    return productsList.asSequence()\n            .sortedBy { it.price }\n            .filter { it.bought }\n            .map { it.price }\n            .average()\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"자바-스트림의-경우\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%98-%EA%B2%BD%EC%9A%B0\" aria-label=\"자바 스트림의 경우 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바 스트림의 경우</h2>\n<p>자바 8부터는 컬렉션 처리를 위해 스트림 기능이 추가되었다. 코틀린의 시퀀스와 유사하게 lazy로 동작한다.</p>\n<p>다만 자바의 스트림과 코틀린의 시퀀스는 아래와 같은 세가지 큰 차이점을 가진다.</p>\n<ul>\n<li>\n<p>코틀린의 시퀀스가 더 많은 처리 함수를 갖고 있다. 그리고 더 사용하기 쉽다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">productsList.stream()\n        .filter { it.bought }\n        .collect(Collectors.toList())\n\nproductsList.asSequence()\n        .filter { it.bought }\n        .toList() // toList 하나로 간단하게 활용 가능</code>\n        </deckgo-highlight-code>\n</li>\n<li>자바 스트림은 병렬 함수를 사용해서 병렬 모드로 실행할 수 있다. 이는 멀티 코어 환경에서 큰 성능 향상을 가져온다. (몇가지 결함이 있으니 주의해서 사용해야 한다. 병렬 함수 내부에서 사용하는 <a href=\"https://dzone.com/articles/think-twice-using-java-8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">common join-fork 스레드풀 관련 이슈</a>가 존재)</li>\n<li>코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등의 일반적인 모듈에서 모두 사용할 수 있다. 자바 스트림은 코틀린/JVM 그리고 JVM 8 이상일때만 동작한다.</li>\n</ul>\n<p>병렬 모드로 성능적인 이득을 얻을 수 있는 곳이 아니라면 코틀린 시퀀스를 사용하는 것이 좋다.</p>\n<h2 id=\"코틀린-시퀀스-디버깅\" style=\"position:relative;\"><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%8B%9C%ED%80%80%EC%8A%A4-%EB%94%94%EB%B2%84%EA%B9%85\" aria-label=\"코틀린 시퀀스 디버깅 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코틀린 시퀀스 디버깅</h2>\n<p>코틀린 시퀀스나 자바 스트림은 단계 요소 흐름을 추적할 수 있는 디버깅 기능을 지원한다.</p>\n<p>아래 플러그인을 이용해 활용할 수 있다.</p>\n<ul>\n<li>Java Stream Debugger</li>\n<li>Kotlin Sequence Debugger</li>\n</ul>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>시퀀스는 lazy하게 처리되므로 아래와 같은 장점이 있다.</p>\n<ul>\n<li>자연스러운 처리 순서를 유지한다.</li>\n<li>최소한만 연산한다.</li>\n<li>무한 시퀀스 형태로 사용할 수 있다.</li>\n<li>각각의 단계에서 컬렉션을 만들어내지 않는다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%88%9C%EC%84%9C%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1\">순서의 중요성</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%B5%9C%EC%86%8C-%EC%97%B0%EC%82%B0\">최소 연산</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EB%AC%B4%ED%95%9C-%EC%8B%9C%ED%80%80%EC%8A%A4\">무한 시퀀스</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EA%B0%81%EA%B0%81%EC%9D%98-%EB%8B%A8%EA%B3%84%EC%97%90%EC%84%9C-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%82%B4%EC%A7%80-%EC%95%8A%EC%9D%8C\">각각의 단계에서 컬렉션을 만들어 내지 않음</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%8B%9C%ED%80%80%EC%8A%A4%EA%B0%80-%EB%B9%A0%EB%A5%B4%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0\">시퀀스가 빠르지 않은 경우</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%98-%EA%B2%BD%EC%9A%B0\">자바 스트림의 경우</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%8B%9C%ED%80%80%EC%8A%A4-%EB%94%94%EB%B2%84%EA%B9%85\">코틀린 시퀀스 디버깅</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-49/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-49","tagSlugs":null},"frontmatter":{"date":"2022-04-01T00:05:00.000Z","description":"Effective Kotlin Item 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-49"}},"staticQueryHashes":["2067870509","251939775","401334301"]}