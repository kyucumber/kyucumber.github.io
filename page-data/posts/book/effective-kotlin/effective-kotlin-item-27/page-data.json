{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-27","result":{"data":{"markdownRemark":{"id":"5fdec98b-c397-5942-af9c-32f0a3ed1d1c","html":"<p>추상화를 통해 변화로부터 코드를 보호할 수 있다.</p>\n<p>추상화를 위해서 아래 네가지 방법을 사용할 수 있다.</p>\n<ul>\n<li>상수</li>\n<li>함수</li>\n<li>클래스</li>\n<li>인터페이스</li>\n</ul>\n<h2 id=\"상수constant-value\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%88%98constant-value\" aria-label=\"상수constant value permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상수(constant value)</h2>\n<p>리터럴은 아무것도 설명하지 않으므로 코드에서 반복적으로 등장할 때 문제가 된다.</p>\n<p>이 리터럴을 상수 프로퍼티로 변경하면 값에 의미있는 이름을 붙일 수 있으며 변경도 쉬워진다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun isPasswordValid(text: String): Boolean {\n    if (text.length &lt; 7) return false\n}</code>\n        </deckgo-highlight-code>\n<p>숫자 7은 비밀번호의 최소 길이를 나타내지만 이해하는데 시간이 걸린다.</p>\n<p>상수로 빼낸다면 훨씬 쉽게 이해할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">const val MIN_PASSWORD_LENGTH = 7\n\nfun isPasswordValid(text: String): Boolean {\n    if (text.length &lt; MIN_PASSWORD_LENGTH) return false\n}</code>\n        </deckgo-highlight-code>\n<p>상수로 추출하면 아래와 같은 장점이 있다.</p>\n<ul>\n<li>이름을 붙여 의미를 나타낼 수 있다.</li>\n<li>나중에 해당 값을 쉽게 변경할 수 있다.</li>\n</ul>\n<h2 id=\"함수\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98\" aria-label=\"함수 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수</h2>\n<p>반복적으로 많이 사용되는 토스트 메시지와 같은 부분은 확장 함수로 만들어 사용할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">Toast.makeText(this, message, Toast.LENGTH_LONG).show()</code>\n        </deckgo-highlight-code>\n<p>확장 함수로 추출하면 아래와 같이 간결하게 호출할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun Context.toast(\n    message: String,\n    duration: Int = Toast.LENGTH_LONG\n) {\n    Toast.makeText(this, message, duration).show()\n}\n\n// 사용\ncontext.toast(message)\n\ntoast(message)</code>\n        </deckgo-highlight-code>\n<p>이렇게 추출하면 토스트를 출력하는 방법이 변경되어도 확장 함수 부분만 수정하면 되어 유지보수성이 향상된다.</p>\n<p>위에서 토스트가 아닌 스낵바라는 형태의 방식으로 출력의 변경이 필요하면 아래와 같이 기존 Context.toast()의 이름을 Context.snakbar()로 수정할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun Context.snackbar(\n    message: String,\n    duration: Int = Toast.LENGTH_LONG\n) {\n    // ...\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 이런 해결 방법은 아래 관점에서 좋지 않다.</p>\n<ul>\n<li>내부적으로 사용하더라도 함수의 이름을 직접 바꾸는 것은 위험할 수 있다. 다른 모듈이 이 함수에 의존하고 있다면 다른 모듈에 큰 문제가 발생할 수 있다.</li>\n<li>함수의 이름은 바꾸기 쉽지만 파라미터는 바꾸기 쉽지 않다. 메시지 지속시간을 나타내는 Toast.LENGTH_LONG이 계속 사용된다는 문제도 있다.</li>\n<li>스낵바를 출력하는 행위가 토스트의 필드에 영향을 받는 것은 좋지 않다. 그렇다고 Snackbar.LENGTH_LONG으로 변경하는 것도 문제를 발생시킬 수 있다.</li>\n</ul>\n<p>메시지의 출력 방법이 바뀔 수 있다는 것을 인지했다면 이때부터 중요한 것은 메시지의 출력 방법이 아닌 사용자에게 메시지를 출력하고 싶다는 의도 자체이다.\n따라서 메시지를 출력하는 더 <strong>추상적인 방법이 필요하며 토스트 출력을 토스트라는 개념과 무관한 showMessage라는 높은 레벨의 함수로 옮길</strong> 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun Context.showMessage(\n    message: String,\n    duration: MessageLength = MessageLength.LONG\n) {\n    val toastDuration = when(duration) {\n        SHORT -&gt; Length.LENGTH_SHORT\n        LONG -&gt; Length.LENGTH_LONG\n    }\n    Toast.makeText(this, message, toastDuration).show()\n}\n\nenum class MessageLength { SHORT, LONG }</code>\n        </deckgo-highlight-code>\n<p>가장 큰 변화는 이름이다. 레이블을 붙이는 방식이 변화되어 큰 차이가 없다고 생각하는 사람도 있지만 이는 컴파일러의 관점이며 사람의 관점에서는 이름이 바뀌면 큰 변화가 일어난 것이다.</p>\n<p>함수의 시그니처는 이 함수가 어떤 추상화를 표현하는지 알려주기 때문에 의미 있는 이름은 굉장히 중요하다.</p>\n<p>함수는 매우 단순한 추상화이지만 제한이 많다. 상태를 유지하지 않으며, 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.</p>\n<h2 id=\"클래스\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"클래스 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스</h2>\n<p>구현을 추상화 할 수 있는 더 강력한 방법으로는 클래스가 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class MessageDisplay(val context: Context) {\n    fun show(\n        message: String,\n        duration: MessageLength = MessageLength.LONG\n    ) {\n        val toastDuration = when(duration) {\n            MessageLength.SHORT -&gt; Length.LENGTH_SHORT\n            MessageLength.LONG -&gt; Length.LENGTH_LONG\n        }\n        Toast.makeText(this, message, toastDuration).show()\n    }\n}\n\nenum class MessageLength { SHORT, LONG }\n\n// 사용\nval messageDisplay = MessageDisplay(context)\nmessageDisplay.show(&quot;Message&quot;)</code>\n        </deckgo-highlight-code>\n<p>클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문이다.</p>\n<ul>\n<li>의존성 주입 프레임워크를 사용해 클래스 생성을 위임할 수도 있다.</li>\n<li>mock 객체를 이용해 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.</li>\n<li>위의 예시에서 메시지를 출력하는 더 다양한 종류의 메소드를 만들 수 있다.</li>\n</ul>\n<h2 id=\"인터페이스\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"인터페이스 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스</h2>\n<p>클래스는 많은 자유를 보장해주지만 여전히 한계가 존재하며 많은 자유를 얻으려면 인터페이스를 이용할 수 있다.</p>\n<p>코틀린 표준 라이브러리를 읽어보면 거의 모든것이 인터페이스로 표현된다는 것을 확인할 수 있다.</p>\n<ul>\n<li>listOf 함수는 List를 리턴하며 여기서 List는 인터페이스이다.</li>\n<li>컬렉션 처리 함수는 Iterable, Collection의 확장 함수로 List, Map 등을 리턴하며 이들은 모두 인터페이스이다.</li>\n<li>프로퍼티 위임은 ReadOnlyProperty 또는 ReadWriteProperty 뒤에 숨겨지며 이들 또한 모두 인터페이스이다.</li>\n</ul>\n<p>라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고 인터페이스를 통해 이를 노출하는 코드를 많이 사용한다. 이렇게 하면 사용자가 클래스를 직접 사용하지 못하므로, 라이브러리를 만드는 사람은 인터페이스만 유지하면 별도의 걱정 없이 원하는 형태로 그 구현을 변경할 수 있다.</p>\n<p>인터페이스 뒤에 객체를 숨기면서 실질적인 구현을 추상화하고 사용자가 추상화된 것에만 의존하게 만들 수 있다. 즉 결합(coupling)을 줄일 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">interface MessageDisplay {\n    fun show(\n        message: String,\n        duration: MessageLength = MessageLength.LONG\n    )\n}\n\nclass ToastDisplay(val context: Context) : MessageDisplay {\n    override fun show(\n        message: String,\n        duration: MessageLength\n    ) {\n        val toastDuration = when (duration) {\n            MessageLength.SHORT -&gt; Length.LENGTH_SHORT\n            MessageLength.LONG -&gt; Length.LENGTH_LONG\n        }\n        Toast.makeText(this, message, toastDuration).show()\n    }\n}\n\nenum class MessageLength { SHORT, LONG }</code>\n        </deckgo-highlight-code>\n<p>이렇게 구성하면 더 많은 자유를 얻을 수 있다.</p>\n<ul>\n<li>각각의 플랫폼(태블릿, IOS, 안드로이드, 웹)에서 구현만 조금 다르게 하면 유연하게 사용할 수 있다.</li>\n<li>인터페이스 페이킹이 클래스 모킹보다 간단해 별도의 모킹 라이브러리를 사용하지 않아도 된다.</li>\n<li>선언과 사용이 분리되어 toastDisplay 등의 실제 클래스를 자유롭게 변경할 수 있다.</li>\n</ul>\n<h2 id=\"추상화가-주는-자유\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%EC%A3%BC%EB%8A%94-%EC%9E%90%EC%9C%A0\" aria-label=\"추상화가 주는 자유 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화가 주는 자유</h2>\n<p>추상화를 하는 몇가지 방법을 정리하면 아래와 같다.</p>\n<ul>\n<li>상수로 추출</li>\n<li>동작을 함수로 래핑</li>\n<li>함수를 클래스로 래핑</li>\n<li>인터페이스 뒤에 클래스를 숨긴다.</li>\n<li>보편적인 객체(universal object)를 특수한 객체(specialistic object)로 래핑한다.</li>\n</ul>\n<p>또한 이를 구현할 때는 여러 도구를 활용할 수 있다.</p>\n<ul>\n<li>제네릭 타입 파라미터 사용</li>\n<li>내부 클래스를 추출한다.</li>\n<li>생성을 제한한다. (팩토리 함수로만 객체 생성할 수 있게 하는 등)</li>\n</ul>\n<h2 id=\"추상화의-문제\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"추상화의 문제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화의 문제</h2>\n<p>추상화도 비용이 발생하기 떄문에 극단적으로 모든 것을 추상화해서는 안된다.</p>\n<p>추상화는 거의 무한하게 할 수 있지만, 어느 순간부터 득보다 실이 많아질 수 있다.</p>\n<blockquote>\n<p>이를 풍자한 FizzBuzz Enterprise Edition이라는 프로젝트가 있음</p>\n</blockquote>\n<p>추상화가 너무 많으면 코드를 이해하기 어렵다. 추상화가 많은 코드를 보면 코드를 제대로 읽기도 전에 두려움에 사로잡힐 수 있다.</p>\n<p>추상화를 이해하려면 예제를 살펴보는게 좋다. 단위 테스트와 문서의 예제는 추상화가 어떻게 사용되는지 확실하게 보여준다.</p>\n<h2 id=\"어떻게-균형을-맞춰야-할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B7%A0%ED%98%95%EC%9D%84-%EB%A7%9E%EC%B6%B0%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 균형을 맞춰야 할까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 균형을 맞춰야 할까?</h2>\n<p>추상화는 많은 자유를 주지만 이해하기 어렵게 만든다.</p>\n<p>극단적인 것은 좋지 않으며 최상의 답은 언제나 그 사이 어딘가에 있다. 이는 아래 요소들에 따라 달라질 수 있다.</p>\n<ul>\n<li>팀의 크기</li>\n<li>팀의 경험</li>\n<li>프로젝트의 크기</li>\n<li>특징 세트(feature set)</li>\n<li>도메인 지식</li>\n</ul>\n<p>적절한 균형을 찾는 것은 어렵지만, 균형을 찾기 위해 사용할 수 있는 몇가지 규칙이 있다.</p>\n<ul>\n<li>많은 개발자가 참여하는 프로젝트는 이후에 객체 생성이나 사용 방법을 변경하기 어렵기 때문에 추상화를 사용하는게 좋다. 최대한 모듈과 부분(part)를 분리하는것이 좋다.</li>\n<li>의존성 주입 프레임워크를 사용하면 생성의 복잡함은 신경쓰지 않아도 된다.</li>\n<li>테스트를 하거나 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는게 좋다.</li>\n<li>프로젝트가 작고 실험적이라면 추상화를 하지 않고도 직접 변경해도 괜찮다. 문제가 발생하면 최대한 빨리 직접 변경하면 된다.</li>\n</ul>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li>추상화는 단순히 중복성을 제거해 코드를 구성하기 위한 것이 아니다.</li>\n<li>추상화를 사용할때의 장점과 단점을 모두 이해하고 프로젝트 내에서 균형을 찾아야 한다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%83%81%EC%88%98constant-value\">상수(constant value)</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%ED%95%A8%EC%88%98\">함수</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%ED%81%B4%EB%9E%98%EC%8A%A4\">클래스</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">인터페이스</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%EC%A3%BC%EB%8A%94-%EC%9E%90%EC%9C%A0\">추상화가 주는 자유</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EB%AC%B8%EC%A0%9C\">추상화의 문제</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B7%A0%ED%98%95%EC%9D%84-%EB%A7%9E%EC%B6%B0%EC%95%BC-%ED%95%A0%EA%B9%8C\">어떻게 균형을 맞춰야 할까?</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-27/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-27","tagSlugs":null},"frontmatter":{"date":"2022-03-06T00:01:00.000Z","description":"Effective Kotlin Item 27. 변화로부터 코드를 보호하려면 추상화를 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 27. 변화로부터 코드를 보호하려면 추상화를 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-27"}},"staticQueryHashes":["2067870509","251939775","401334301"]}