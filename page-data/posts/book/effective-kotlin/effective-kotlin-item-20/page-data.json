{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-20","result":{"data":{"markdownRemark":{"id":"fe2598eb-d3ce-589f-8140-08da465365dd","html":"<p>다음과 같이 숫자를 특정 범위에 맞추는 알고리즘은 stdlib의 coerceIn 확장함수로 이미 구현되어 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">val percent = when {\n    numberFromUser &gt; 100 -&gt; 100\n    numberFromUser &lt; 0 -&gt; 0\n    else numberFromUser\n}\n\n// 이미 존재\nval percent = numberFromUser.coerceIn(0, 100)</code>\n        </deckgo-highlight-code>\n<p>이미 있는 것을 활용하면 코드가 짧아진다는 것 이외에도 다양한 장점이 있다.</p>\n<ul>\n<li>코드 작성 속도가 빨라진다.</li>\n<li>구현을 따로 읽지 않아도 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있다.</li>\n<li>직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다.</li>\n<li>제작자들이 한번만 최적화하면, 모든 곳이 최적화의 혜택을 받을 수 있다.</li>\n</ul>\n<h2 id=\"표준-라이브러리-살펴보기\" style=\"position:relative;\"><a href=\"#%ED%91%9C%EC%A4%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"표준 라이브러리 살펴보기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>표준 라이브러리 살펴보기</h2>\n<p>일반적인 알고리즘은 대부분 정의되어 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">override fun saveCallResult(item: SourceResponse) {\n    var sourceList = ArrayList&lt;SourceEntity&gt;()\n\n    item.sources.forEach {\n        var sourceEntity = SourceEntity()\n        sourceEntity.id = it.id\n        sourceEntity.category = it.category\n        sourceEntity.country = it.country\n    }\n    db.insertSources(sourceList)\n}</code>\n        </deckgo-highlight-code>\n<p>어떤 자료형을 다른 자료형으로 매핑하기 위한 map과 같은 함수는 이미 제공되고 있으니, 위의 코드에서도 forEach를 사용하지 말고 map을 사용하는 것이 좋다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">override fun saveCallResult(item: SourceResponse) {\n    val sourceEntries = item.sources.map(::sourceToEntry)\n    db.insertSources(sourceList)\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"나만의-유틸리티-구현하기\" style=\"position:relative;\"><a href=\"#%EB%82%98%EB%A7%8C%EC%9D%98-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"나만의 유틸리티 구현하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>나만의 유틸리티 구현하기</h2>\n<p>상황에 따라 표준 라이브러리에 없는 알고리즘이 필요할 수도 있다.</p>\n<p>컬렉션에 있는 모든 숫자의 곱을 계산하는 라이브러리가 필요한 경우 범용 유틸리티 함수(universal utility function)로 정의하는것이 좋다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">fun Iterable&lt;Int&gt;.product() = fold(1) { acc, i -&gt; acc * i }</code>\n        </deckgo-highlight-code>\n<p>필요 없는 함수를 중복해서 만들지 않게 기존에 관련된 함수가 있는지 탐색하는 과정이 필요하다.</p>\n<p>많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있다.</p>\n<p>확장 함수는 앞의 방법과 비교해 다음과 같은 장점을 가지고 있다.</p>\n<ul>\n<li>함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다.</li>\n<li>톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋다.</li>\n<li>수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다.</li>\n<li>확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있다.</li>\n</ul>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li>일반적인 알고리즘을 반복해서 만들지 말자. 대부분 stdlib에 이미 정의되어 있다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-20/#%ED%91%9C%EC%A4%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\">표준 라이브러리 살펴보기</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-20/#%EB%82%98%EB%A7%8C%EC%9D%98-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">나만의 유틸리티 구현하기</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-20/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-20/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-20","tagSlugs":null},"frontmatter":{"date":"2022-02-27T00:00:01.000Z","description":"Effective Kotlin Item20. 일반적인 알고리즘을 반복해서 구현하지 말라","tags":null,"title":"이펙티브 코틀린 아이템 20. 일반적인 알고리즘을 반복해서 구현하지 말라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-20"}},"staticQueryHashes":["2067870509","251939775","401334301"]}