{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-37","result":{"data":{"markdownRemark":{"id":"34a2c509-0dc5-54bb-8767-4409bf5a22ba","html":"<p>데이터를 한꺼번에 전달해야 하는 경우 다음과 같은 클래스를 사용한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">data class Player(\n    val id: Int,\n    val name: String,\n    val points: Int\n)</code>\n        </deckgo-highlight-code>\n<p>data 한정자를 붙이면 아래와 같은 몇가지 함수가 자동으로 생성된다.</p>\n<ul>\n<li>toString</li>\n<li>equals와 hashCode</li>\n<li>\n<p>copy </p>\n<ul>\n<li>copy는 immutable 데이터 클래스를 만들 때 편리하게 활용할 수 있다. copy는 객체를 얕은 복사 한다.</li>\n</ul>\n</li>\n<li>\n<p>componentN </p>\n<ul>\n<li>\n<p>위치를 기반으로 객체를 해제할 수 있다. 위치를 잘못 지정하면 큰 문제가 발생할 수 있으니 주의한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val (id, name, pts) = player</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"튜플-대신-데이터-클래스-사용하기\" style=\"position:relative;\"><a href=\"#%ED%8A%9C%ED%94%8C-%EB%8C%80%EC%8B%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"튜플 대신 데이터 클래스 사용하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>튜플 대신 데이터 클래스 사용하기</h2>\n<p>데이터 클래스는 튜플보다 많은 것을 제공한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">public data class Pair&lt;out A, out B&gt;(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = &quot;($first, $second)&quot;\n}\n\npublic data class Triple&lt;out A, out B, out C&gt;(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = &quot;($first, $second, $third)&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>코틀린에 남아있는 튜플은 Pair와 Triple이 전부이다. 튜플은 좋아 보이지만 데이터 클래스를 사용하는것이 더 좋기 때문에 점차 없어졌다. 이는 몇가지 지역적인 목적으로 남아있다.</p>\n<ul>\n<li>\n<p>값에 간단하게 이름을 붙일 때</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val (description, color) = when {\n  degrees &lt; 5 -&gt; &quot;cold&quot; to Color.BLUE\n  degrees &lt; 23 -&gt; &quot;mild&quot; to Color.YELLOW\n  else -&gt; &quot;hot&quot; to COLOR.RED\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>표준 라이브러리에서 볼 수 있는 것 처럼 미리 알 수 없는 aggregate(집합)을 표현할 때</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val (odd, even) = numbers.partition { it % 2 == 1 }\nval map = mapOf(1 to &quot;San Francisco&quot;, 2 to &quot;Amsterdam&quot;)</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>위 경우를 제외하면 데이터 클래스를 사용하는게 좋다.</p>\n<p>예를 들어 fullname과 name을 나타내는 코드를 정의할 때 <code class=\"language-text\">Pair&lt;String, String&gt;</code>을 사용하면 해당 Pair가 전체 이름을 나타내는것을 인지하기 어렵다.</p>\n<p>이를 데이터 클래스로 만들어도 큰 추가 비용이 들지 않으며 다음과 같은 장점이 있다.</p>\n<ul>\n<li>함수의 리턴 타입이 더 명확해진다.</li>\n<li>리턴 타입이 더 짧아지며 전달하기 쉬워진다.</li>\n<li>사용자가 데이터 클래스에 적혀있는 것과 다른 이름을 활용해 변수를 해제하면, 경고를 출력한다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-37/#%ED%8A%9C%ED%94%8C-%EB%8C%80%EC%8B%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">튜플 대신 데이터 클래스 사용하기</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-37/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-37","tagSlugs":null},"frontmatter":{"date":"2022-03-12T00:10:00.000Z","description":"Effective Kotlin Item 37. 데이터 집합 표현에 data 한정자를 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 37. 데이터 집합 표현에 data 한정자를 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-37"}},"staticQueryHashes":["2067870509","251939775","401334301"]}