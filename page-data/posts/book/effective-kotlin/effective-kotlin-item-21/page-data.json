{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-21","result":{"data":{"markdownRemark":{"id":"21020009-a017-5273-ae5f-dc49aa20896f","html":"<p>코틀린은 코드 재사용과 관련해 프로퍼티 위임이라는 새로운 기능을 제공한다.</p>\n<p>프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해 재사용할 수 있다.</p>\n<p>lazy를 이용해 지연 프로퍼티를 사용하면 생성과 동시에 값을 초기화 할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val value by lazy { createValue() }\n\nfun createValue(): String = &quot;Test&quot;</code>\n        </deckgo-highlight-code>\n<p>프로퍼티 위임을 사용해 observable 패턴도 쉽게 만들 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">var items: List&lt;Item&gt; by \n    Delegates.observable(listOf()) { _, _, _ -&gt;\n        notifyDataSetChanged()\n    }\n\nvar key: String? by\n    Delegates.observable(null) { _, old, new -&gt;\n        Log.e(&quot;Key changed from $old to $new&quot;)\n    }</code>\n        </deckgo-highlight-code>\n<p>간단한 프로퍼티 델리게이트를 살펴보자.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">// AS-IS 델리게이트 적용 전\nvar token: String? = null\n    get() {\n        print(&quot;token returned value $field&quot;)\n        return field\n    }\n    set(value) {\n        print(&quot;token changed from $field to $value&quot;)\n        field = value\n    }\n\nvar attempts: Int = 0\n    get() {\n        print(&quot;attempts returned value $field&quot;)\n        return field\n    }\n    set(value) {\n        print(&quot;attempts changed from $field to $value&quot;)\n        field = value\n    }</code>\n        </deckgo-highlight-code>\n<p>위 두 token, attempts는 타입은 다르지만 거의 같은 처리를 하며 프로젝트 내에서 자주 반복되어 사용될 만한 패턴이다. 따라서 프로퍼티 위임을 활용해 추출할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">// TO-BE 델리게이트 적용 후\nvar token: String? by LoggingProperty(null)\nvar attempts: Int by LoggingProperty(0)\n\nprivate class LoggingProperty&lt;T&gt;(var value: T) {\n    operator fun getValue(\n        thisRef: Any?,\n        prop: KProperty&lt;*&gt;\n    ): T {\n        print(&quot;${prop.name} returned value $value&quot;)\n        return value\n    }\n    \n    operator fun setValue(\n        thisRef: Any?,\n        prop: KProperty&lt;*&gt;,\n        newValue: T\n    ) {\n        val name = prop.name\n        print(&quot;changed from $value to $newValue&quot;)\n        value = newValue\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>프로퍼티 위임이 어떻게 동작하는지 이해하려면 by가 어떻게 컴파일되는지 살펴보자</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">@JvmField\nprivate val &#39;token$delegate&#39; = LoggingProperty&lt;String?&gt;(null)\nvar token: String?\n    get() = &#39;token$delegate&#39;.getValue(this, ::token)\n    set(value) { &#39;token$delegate&#39;.setValue(this, ::token, value) }</code>\n        </deckgo-highlight-code>\n<p>멤버 함수 뿐만 아니라 확장 함수로도 만들 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val map: Map&lt;String, Any&gt; = mapOf(\n    &quot;name&quot; to &quot;Marcin&quot;,\n    &quot;kotlinProgrammer&quot; to true\n)\n\nval name by map\n\ninline operator fun &lt;V, V1 : V&gt; Map&lt;in String, V&gt;\n    .getvalue(thisRef: Any?, property: KProperty&lt;*&gt;): V1 = \n    getOrImplicitDefault(property.name) as V1</code>\n        </deckgo-highlight-code>\n<p>코틀린 stdlib의 아래 프로퍼티 델리게이터를 알아 두면 유용하게 활용할 수 있다.</p>\n<ul>\n<li>lazy</li>\n<li>Delegates.observable</li>\n<li>Delegates.vetoable</li>\n<li>Delegates.notNull</li>\n</ul>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>프로퍼티 델리게이트는 프로퍼티와 관련된 다양한 조작을 할 수 있다. 표준 라이브러리의 lazy와 observable이 대표적인 예이다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-21/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-21/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-21","tagSlugs":null},"frontmatter":{"date":"2022-02-27T00:02:00.000Z","description":"Effective Kotlin Item21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라","tags":null,"title":"이펙티브 코틀린 아이템 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-21"}},"staticQueryHashes":["2067870509","251939775","401334301"]}