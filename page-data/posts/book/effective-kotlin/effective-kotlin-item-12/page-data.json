{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-12","result":{"data":{"markdownRemark":{"id":"c8432c53-8fd6-533b-9b91-0c7a4997c418","html":"<p>연산자 오버로딩은 굉장히 강력한 기능이지만 위험할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">fun Int.factorial(): Int = (1..this).product()\n// 생략\n\noperator fun Int.not() = factorial()\nprint(10 * !6) // 7200</code>\n        </deckgo-highlight-code>\n<p>팩토리얼은 ! 기호를 사용해 표기하니 위와 같이 구현한다면 안된다.\n함수의 이름이 not이기 때문에 논리 연산에 사용해야지 팩토리얼 연산에 연산자 오버로딩을 사용하면 안된다.</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>대응되는 함수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+a</td>\n<td>a.unaryPlus()</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>a.unaryMinus()</td>\n</tr>\n<tr>\n<td>!a</td>\n<td>a.not()</td>\n</tr>\n<tr>\n<td>++a</td>\n<td>a.inc()</td>\n</tr>\n<tr>\n<td>—a</td>\n<td>a.dec()</td>\n</tr>\n<tr>\n<td>a + b</td>\n<td>a.plus(b)</td>\n</tr>\n<tr>\n<td>a * b</td>\n<td>a.times(b)</td>\n</tr>\n<tr>\n<td>a / b</td>\n<td>a.div(b)</td>\n</tr>\n<tr>\n<td>a..b</td>\n<td>a.rangeTo(b)</td>\n</tr>\n<tr>\n<td>a in b</td>\n<td>b.contains(a)</td>\n</tr>\n<tr>\n<td>a += b</td>\n<td>a.plusAssign(b)</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://kotlinlang.org/docs/operator-overloading.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kotlin docs operator overloading</a></p>\n<p>따라서 팩토리얼을 계산하기 위해 ! 연산자를 사용하면 안된다. 이는 관례에 어긋나기 때문이다.</p>\n<h2 id=\"분명하지-않은-경우\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%AA%85%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0\" aria-label=\"분명하지 않은 경우 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분명하지 않은 경우</h2>\n<p>관례를 충족하는지 아닌지 확실하지 않은 경우도 존재할 것이다. 이 경우는 infix를 활용한 확장 함수를 사용하는 것이 좋다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">infix fun Int.timesRepeated(operation: () -&gt; Unit) = {\n    repeat(this) { operation() }\n}</code>\n        </deckgo-highlight-code>\n<p>top-level function을 사용하는 것도 좋다. 위와 같이 함수를 n번 호출하는 것은 다음과 같은 형태로 이미 구현되어 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">repeat(3) { print(&quot;Hello&quot;) }</code>\n        </deckgo-highlight-code>\n<h2 id=\"규칙을-무시해도-되는-경우\" style=\"position:relative;\"><a href=\"#%EA%B7%9C%EC%B9%99%EC%9D%84-%EB%AC%B4%EC%8B%9C%ED%95%B4%EB%8F%84-%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"규칙을 무시해도 되는 경우 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>규칙을 무시해도 되는 경우</h2>\n<p>지금까지 설명한 연산자 오버로딩 규칙을 무시해도 되는 중요한 경우가 있다. 이는 <strong>DSL을 설계할 때</strong>이다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">body {\n    div {\n        + &quot;Some text&quot;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위는 HTML DSL이며 문자열 앞에 String.unaryPlus가 사용되었지만 문제가 되지 않는다. 이는 DSL 코드이기 때문이다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>연산자 오버로딩은 이름에 의미에 맞게 사용하자.</p>\n<p>꼭 연산자 형태로 사용하고 싶다면 infix 확장 함수 또는 top-level function을 사용하자</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-12/#%EB%B6%84%EB%AA%85%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0\">분명하지 않은 경우</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-12/#%EA%B7%9C%EC%B9%99%EC%9D%84-%EB%AC%B4%EC%8B%9C%ED%95%B4%EB%8F%84-%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">규칙을 무시해도 되는 경우</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-12/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-12/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-12","tagSlugs":null},"frontmatter":{"date":"2022-02-12T00:10:00.000Z","description":"Effective Kotlin Item 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-12"}},"staticQueryHashes":["2067870509","251939775","401334301"]}