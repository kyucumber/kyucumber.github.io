{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-45","result":{"data":{"markdownRemark":{"id":"9e2901e5-61f8-50ea-a506-f49f44d8b10b","html":"<p>상황에 따라 객체 생성에 굉장히 큰 비용이 들어갈 수도 있다. 따라서 불필요한 객체 생성을 피하는 것이 최적화의 관점에서 좋다.</p>\n<p>JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면, 기존의 문자열을 재사용한다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">val str1 = &quot;Lorem&quot;\nval str2 = &quot;Lorem&quot;\n\nprint(str1 == str2) // true\nprint(str1 === str2) // true</code>\n        </deckgo-highlight-code>\n<p>Integer와 Long처럼 박싱된 기본 자료형도 작은 경우 재사용 된다.</p>\n<ul>\n<li>Integer는 -128 ~ 127 범위를 캐싱한다.</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">val i1: Int? = 1\nval i2: Int? = 1\n\nprintln(i1 == i2) // true\nprintln(i1 === i2) // true\n\nval i1: Int? = 1024\nval i2: Int? = 1024\n\nprintln(i1 == i2) // true\nprintln(i1 === i2) // false</code>\n        </deckgo-highlight-code>\n<p>nullable 타입은 int 자료형 대신 Integer 자료형을 사용하게 강제된다. </p>\n<p>Int를 사용하면 일반적으로 기본 자료형 int로 컴파일된다. 하지만 nullable이나 타입 아규먼트로 사용할 경우 Integer로 컴파일된다.</p>\n<p>이는 기본 자료형은 null일 수 없고, 타입 아규먼트로도 사용할 수 없기 때문이다. 이러한 메커니즘은 객체 생성 비용에 큰 영향을 준다.</p>\n<h2 id=\"객체-생성-비용은-항상-클까\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B9%84%EC%9A%A9%EC%9D%80-%ED%95%AD%EC%83%81-%ED%81%B4%EA%B9%8C\" aria-label=\"객체 생성 비용은 항상 클까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 생성 비용은 항상 클까?</h2>\n<p>어떤 객체를 랩(wrap)하면 크게 세가지 비용이 발생한다.</p>\n<ul>\n<li>객체는 더 많은 용량을 차지한다. 객체 뿐만 아니라 객체에 대한 레퍼런스 또한 공간을 차지한다.</li>\n<li>요소가 캡슐화되어 있다면 접근에 추가적인 함수 호출이 필요하다. 이 비용은 굉장히 적지만 수 많은 객체를 처리하면 이 비용도 굉장히 커진다.</li>\n<li>객체는 생성되어야 한다. 메모리 영역 할당, 이에 대한 레퍼런스를 만드는 등의 작업이 필요하며 이는 적은 비용이지만 모이면 큰 비용이 된다.</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class A\nprivate val a = A()\n\n// 2.698 ns/op\nfun accessA(blackhole: Blackhole) {\n    blackhole.consume(a)\n}\n\n// 3.814 ns/op\nfun accessA(blackhole: Blackhole) {\n    blackhole.consume(A())\n}\n\n// 3828.540 ns/op\nfun accessA(blackhole: Blackhole) {\n    blackhole.consume(List(1000) { a })\n}\n\n// 5322.857 ns/op\nfun accessA(blackhole: Blackhole) {\n    blackhole.consume(List(1000) { A() })\n}</code>\n        </deckgo-highlight-code>\n<p>위에서 재사용, 객체 생성을 비교한 부분을 보면 미미한 차이이지만 모이면 꽤 큰 차이가 발생하는것을 알 수 있다.</p>\n<p>객체를 제거하면 위에서 말한 세가지 비용 모두를 피할 수 있으며 객체를 재사용하면 첫번째와 세번째에 대한 비용을 제거할 수 있다.</p>\n<h2 id=\"객체-선언\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%84%A0%EC%96%B8\" aria-label=\"객체 선언 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 선언</h2>\n<p>객체를 재사용하는 간단한 방법은 객체 선언을 사용하는 것이다.(싱글톤)</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">sealed class LinkedList&lt;T&gt;\n\nclass Node&lt;T&gt;(\n    val head: T,\n    val tail: LinkedList&lt;T&gt;\n): LinkedList&lt;T&gt;()\n\nclass Empty&lt;T&gt;: LinkedList&lt;T&gt;()\n\nval list1: LinkedList&lt;Int&gt; = Node(1, Node(2, Node(3, Empty())))\nval list2: LinkedList&lt;String&gt; = Node(&quot;A&quot;, Node(&quot;B&quot;, Empty()))</code>\n        </deckgo-highlight-code>\n<p>위 구현에서는 List를 만들 때 마다 <strong>Empty 인스턴스를 만들어야 한다는 문제점</strong>이 있다.</p>\n<p>Empty를 하나만 만들고 모든 리스트에서 활용할 수 있게 한다면 좋겠지만 제네릭 타입이 일치하지 않아 문제가 될 수 있다.</p>\n<p>이를 해결하기 위해 <code class=\"language-text\">LinkedList&lt;Nothing&gt;</code>을 활용할 수 있다. 여기서 리스트는 immutable이고 이 타입은 out 위치에만 사용되므로 현재 상황에서 타입 아규먼트를 covariant로 만드는 것은 의미있는 일이다. </p>\n<p>Empty 인스턴스에 대한 문제는 아래와 같이 Nothing을 활용해 개선할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">sealed class LinkedList&lt;out T&gt;\n\nclass Node&lt;T&gt;(\n    val head: T,\n    val tail: LinkedList&lt;T&gt;\n): LinkedList&lt;T&gt;()\n\nobject Empty: LinkedList&lt;Nothing&gt;()\n\nval list1: LinkedList&lt;Int&gt; = Node(1, Node(2, Node(3, Empty)))\nval list2: LinkedList&lt;String&gt; = Node(&quot;A&quot;, Node(&quot;B&quot;, Empty))</code>\n        </deckgo-highlight-code>\n<p>이러한 트릭은 immutable sealed 클래스를 정의할 때 자주 사용된다.</p>\n<p>mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 검출하기 어려울 수 있으므로 mutable에 위와 같은 트릭을 사용하는 것은 좋지 않다.\nmutable 객체는 캐시하지 않는다는 규칙을 지키자.</p>\n<h2 id=\"캐시를-활용하는-팩토리-함수\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\" aria-label=\"캐시를 활용하는 팩토리 함수 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 활용하는 팩토리 함수</h2>\n<p>일반적으로 객체는 생성자를 사용해서 만든다. 하지만 팩토리 메소드를 사용해서 만드는 경우도 있다.</p>\n<p>팩토리 함수는 캐시를 가질 수 있으며 팩토리 함수에서는 항상 같은 객체를 리턴하게 만들 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// stdlib의 emptyList\nfun &lt;T&gt; List&lt;T&gt; emptyList() {\n    return EMPTY_LIST;\n}</code>\n        </deckgo-highlight-code>\n<p>모든 순수 함수는 캐싱을 활용할 수 있으며 이를 메모이제이션(memoization)이라고 부른다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">private val connections =\n    mutableMapOf&lt;String, Connection&gt;()\n\nfun getConnection(host: String) =\n    connections.getOrPut(host) { createConnection(host) }\n\nprivate val FIB_CACHE = mutableMapOf&lt;Int, BigInteger&gt;()\n\nfun ib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {\n    if (n &lt;= 1) BigInteger.ONE else fib(n - 1) + fib(n - 2)\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 메모제이션을 활용할 수 있지만 <strong>캐시를 위한 Map을 저장해야 하므로 더 많은 메모리를 사용하는 단점</strong>이 있다.</p>\n<p>메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋다.</p>\n<ul>\n<li>\n<p>WeakReference</p>\n<ul>\n<li>가비지 컬렉터가 값을 정리하는 것을 막지 않는다. 따라서 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거된다.</li>\n</ul>\n</li>\n<li>\n<p>SoftReference</p>\n<ul>\n<li>메모리가 부족해 추가로 필요한 경우만 정리한다. 따라서 캐시를 만들때는 SoftReference를 사용하는것이 좋다.</li>\n</ul>\n</li>\n</ul>\n<p>캐시는 언제나 메모리와 성능의 트레이드 오프가 발생하므로 여러 상황을 잘 고려해 사용하자.</p>\n<h2 id=\"무거운-객체를-외부-스코프로-보내기\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EA%B1%B0%EC%9A%B4-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%99%B8%EB%B6%80-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A1%9C-%EB%B3%B4%EB%82%B4%EA%B8%B0\" aria-label=\"무거운 객체를 외부 스코프로 보내기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무거운 객체를 외부 스코프로 보내기</h2>\n<p>무거운 객체를 외부 스코프로 보내는 방법이 있다. 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋다.</p>\n<ul>\n<li>\n<p>최대값의 수를 세는 확장함수 최적화</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// AS-IS\nfun &lt;T: Comparable&lt;T&gt;&gt; Iterable&lt;T&gt;.countMax(): Int {\n    return count { it == this.max() }\n}</code>\n        </deckgo-highlight-code>\n<p>max를 찾은 뒤 활용하므로 코드의 성능이 좋아진다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// TO-BE\nfun &lt;T: Comparable&lt;T&gt;&gt; Iterable&lt;T&gt;.countMax(): Int {\n    val max = this.max()\n    return count { it == max }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>정규식 톱 레벨로 보내 최적화하기</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// AS-IS\nfun String.isValidIpAddress(): Boolean {\n    return this.matches(&quot;\\\\A(?:(?:25[0-5]2[0-4]....\\\\z&quot;.toRegex())\n}</code>\n        </deckgo-highlight-code>\n<p>Regex 객체를 매번 새로 만드는 것은 성능적으로 문제를 일으킨다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// TO-BE\nprivate val IS_VALID_EMAIL_REGEX = &quot;\\\\A(?:(?:25[0-5]2[0-4]....\\\\z&quot;.toRegex()\n\nfun String.isValidIpAddress(): Boolean {\n    return this.matches(IS_VALID_EMAIL_REGEX)\n}</code>\n        </deckgo-highlight-code>\n<p>그리고 이 함수가 한 파일에 다른 함수와 함께 있을 때, 함수를 사용하지 않으면 정규식이 만들어지는 것 자체가 낭비이므로 아래와 같이 지연 초기화를 사용할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// TO-BE + lazy\nprivate val IS_VALID_EMAIL_REGEX by lazy {\n    &quot;\\\\A(?:(?:25[0-5]2[0-4]....\\\\z&quot;.toRegex()\n}\n\nfun String.isValidIpAddress(): Boolean {\n    return this.matches(IS_VALID_EMAIL_REGEX)\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2 id=\"지연-초기화\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%B0-%EC%B4%88%EA%B8%B0%ED%99%94\" aria-label=\"지연 초기화 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지연 초기화</h2>\n<p>무거운 클래스를 만들 때 지연되게 만드는 것이 좋을 때가 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class A {\n    val b = B()\n    val c = D()\n    val d = D()\n\n    // ..\n}</code>\n        </deckgo-highlight-code>\n<p>내부의 인스턴스를 지연 초기화하면 A 생성 과정을 가볍게 만들 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">class A {\n    val b by lazy { B() }\n    val c by lazy { D() }\n    val d by lazy { D() }\n\n    // ..\n}</code>\n        </deckgo-highlight-code>\n<p>이는 아래와 같은 단점도 가지고 있기 때문에 상황에 맞게 사용해야 한다.</p>\n<ul>\n<li>처음 호출 때 무거운 객체의 초기화가 필요해 <strong>첫번째 호출 때 응답 시간이 오래 걸린다</strong>.</li>\n<li>성능 테스트가 복잡해지는 문제가 있다.</li>\n</ul>\n<h2 id=\"기본-자료형-사용하기\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"기본 자료형 사용하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 자료형 사용하기</h2>\n<p>JVM은 숫자와 문자 등의 기본 요소를 나타내기 위한 기본 자료형(primitives)을 가지고 있다.</p>\n<p>코틀린 / JVM 컴파일러는 내부적으로 이러한 기본 자료형을 사용하지만 다음과 같은 상황에서는 기본 자료형을 랩(wrap)한 자료형이 사용된다.</p>\n<ul>\n<li>nullable 타입을 연산할 때(기본 자료형은 null일 수 없으므로)</li>\n<li>타입을 제네릭으로 사용할 때</li>\n</ul>\n<p>코틀린과 자바 간의 자료형을 간단히 비교하면 아래와 같다.</p>\n<ul>\n<li>Kotlin Int → Java int</li>\n<li>Kotlin Int? → Integer</li>\n<li>Kotlin List<Int> → List<Integer></li>\n</ul>\n<p>위 내용을 잘 알면 기본 자료형을 사용하게 코드를 최적화할 수 있다. 이 작업은 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있다.</p>\n<p>코틀린으로 컬렉션 내부의 최댓값을 리턴하는 함수를 만들어보자.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">fun Iterable&lt;Int&gt;.maxOrNull(): Int? {\n    var max: Int? = null\n    for (i in this) {\n        max = if(i &gt; (max ?: Int.MIN_VALUE)) i else max\n    }\n    return max\n}</code>\n        </deckgo-highlight-code>\n<p>이 구현에는 두가지 심각한 단점이 있다.</p>\n<ul>\n<li>각각의 단계에서 Elvis operator를 사용해야 한다.</li>\n<li>nullable을 사용해 JVM 내부에서 int가 아니라 Integer로 연산이 일어난다.</li>\n</ul>\n<p>두가지 문제를 해결하려면 아래와 같이 while을 사용해 반복을 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">fun Iterable&lt;Int&gt;.maxOrNull(): Int? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max: Int = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max &lt; e) max = e\n    }\n    return max\n}</code>\n        </deckgo-highlight-code>\n<p>책에서는 컬렉션에 100~1000만개 요소를 넣었을 경우 518ms, 289ms로 대략 두배정도의 차이가 존재한다고 한다. 하지만 이 정도의 최적화는 성능이 그렇게까지 중요하지 않은 코드에서는 큰 의미가 없는 최적화이다.</p>\n<p>라이브러리를 구현한다면 성능이 중요할 수 있다. 위와 같은 최적화는 성능이 아주 중요한 경우에 활용하자.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>객체 생성 시 문제를 피하는 아래 방법들을 살펴보았다.</p>\n<ul>\n<li>캐시를 활용하는 팩토리 함수</li>\n<li>무거운 객체를 외부 스코프로 보내기</li>\n<li>지연 초기화</li>\n<li>기본 자료형 사용하기</li>\n</ul>\n<p>이러한 최적화에 큰 변경이 필요하거나, 다른 코드에 문제를 일으킬 수 있다면 최적화를 미루는 것도 방법이다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B9%84%EC%9A%A9%EC%9D%80-%ED%95%AD%EC%83%81-%ED%81%B4%EA%B9%8C\">객체 생성 비용은 항상 클까?</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EA%B0%9D%EC%B2%B4-%EC%84%A0%EC%96%B8\">객체 선언</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EC%BA%90%EC%8B%9C%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\">캐시를 활용하는 팩토리 함수</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EB%AC%B4%EA%B1%B0%EC%9A%B4-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%99%B8%EB%B6%80-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A1%9C-%EB%B3%B4%EB%82%B4%EA%B8%B0\">무거운 객체를 외부 스코프로 보내기</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EC%A7%80%EC%97%B0-%EC%B4%88%EA%B8%B0%ED%99%94\">지연 초기화</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">기본 자료형 사용하기</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-45/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-45","tagSlugs":null},"frontmatter":{"date":"2022-03-26T00:07:00.000Z","description":"Effective Kotlin Item 45. 불필요한 객체 생성을 피하라","tags":null,"title":"이펙티브 코틀린 아이템 45. 불필요한 객체 생성을 피하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-45"}},"staticQueryHashes":["2067870509","251939775","401334301"]}