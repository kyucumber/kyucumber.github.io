{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-39","result":{"data":{"markdownRemark":{"id":"8e92f096-c02f-5b10-b78c-6367e8f729df","html":"<p>상수 모드를 가진 클래스를 많이 볼 수 있다. 이러한 상수 모드를 태그라고 부르며, 태그를 포함한 클래스를 태그 클래스라고 부른다. 태그 클래스는 서로 다른 책임을 한 클래스에 태그로 넣는 문제를 가진다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class ValueMatcher&lt;T&gt; private constructor(\n    private val value: T? = null,\n    private val matcher: Matcher\n){\n    fun match(value: T?) = when(matcher) {\n        Matcher.EQUAL -&gt; value == this.value\n        Matcher.NOT_EQUAL -&gt; value != this.value\n        Matcher.LIST_EMPTY -&gt; value is List&lt;*&gt; &amp;&amp; value.isEmpty()\n        Matcher.LIST_NOT_EMPTY -&gt; value is List&lt;*&gt; &amp;&amp; value.isNotEmpty()\n    }\n    enum class Matcher {\n        EQUAL,\n        NOT_EQUAL,\n        LIST_EMPTY,\n        LIST_NOT_EMPTY\n    }\n    companion object {\n        fun &lt;T&gt; equal(value: T) = \n            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.EQUAL)\n\n        fun &lt;T&gt; notEqual(value: T) =\n            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.NOT_EQUAL)\n\n        fun &lt;T&gt; emptyList(value: T) =\n            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_EMPTY)\n\n        fun &lt;T&gt; notEmptyList(value: T) =\n            ValueMatcher&lt;T&gt;(value = value, matcher = Matcher.LIST_NOT_EMPTY)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위 접근 방법에는 아래와 같은 많은 단점이 존재한다.</p>\n<ul>\n<li>한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가된다.</li>\n<li>여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있다. (value는 <code class=\"language-text\">LIST_EMPTY</code>, <code class=\"language-text\">LIST_NOT_EMPTY</code>일때 사용되지 않는다.)</li>\n<li>요소가 여러 목적을 가지고 요소를 여러 방법으로 설정할 수 있는 경우 상태의 일관성과 정확성을 지키기 어렵다.</li>\n<li>팩토리 메소드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 어렵다.</li>\n</ul>\n<p>코틀린은 그래서 태그 클래스보다 sealed 클래스를 많이 사용한다. 한 클래스에 여러 모드를 만드는 방법 대신에 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.</p>\n<p>이러한 클래스에는 아래와 같이 sealed 한정자를 붙여 서브클래스 정의를 제한할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">sealed class ValueMatcher&lt;T&gt; {\n    abstract fun match(value: T): Boolean\n\n    class Equal&lt;T&gt;(private val value: T) : ValueMatcher&lt;T&gt;() {\n        override fun match(value: T): Boolean = value == this.value\n    }\n\n    class NotEqual&lt;T&gt;(private val value: T) : ValueMatcher&lt;T&gt;() {\n        override fun match(value: T): Boolean = value != this.value\n    }\n\n    class EmptyList&lt;T&gt;() : ValueMatcher&lt;T&gt;() {\n        override fun match(value: T): Boolean = value is List&lt;*&gt; &amp;&amp; value.isEmpty()\n    }\n\n    class NotEmptyList&lt;T&gt;() : ValueMatcher&lt;T&gt;() {\n        override fun match(value: T): Boolean = value is List&lt;*&gt; &amp;&amp; value.isNotEmpty()\n    }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"sealed-한정자\" style=\"position:relative;\"><a href=\"#sealed-%ED%95%9C%EC%A0%95%EC%9E%90\" aria-label=\"sealed 한정자 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sealed 한정자</h2>\n<p>sealed 한정자를 반드시 사용해야 하는 것은 아니다. 대신 abstract 한정자를 사용할 수도 있지만 sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한한다.</p>\n<p>sealed class는 아래와 같은 장점을 가진다.</p>\n<ul>\n<li>외부에서 추가적인 서브클래스를 만들 수 없으므로 <strong>타입이 추가되지 않는 것이 보장</strong>된다. 따라서 when을 사용할 때 else 브랜치를 만들 필요가 없다.</li>\n<li>위 장점을 이용해 새로운 기능을 쉽게 추가할 수 있으며 when 구문에서 처리하는 것을 잊어버리지 않을 수 있다.</li>\n</ul>\n<p>when은 모드를 구분해 다른 처리를 만들때 편리하게 사용할 수 있다. 어떤 처리를 각각 서브클래스에 정의하지 않고 when을 활용하는 확장함수를 통해 한번에 구현할 수 있다.</p>\n<p>아래는 위 예제에서 reversed라는 확장 함수를 통해 클래스의 종류에 따라 서로 다른 처리를 하게 하는 예제이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun &lt;T&gt; ValueMatcher&lt;T&gt;.reversed(): ValueMatcher&lt;T&gt; =\n    when (this) {\n        is ValueMatcher.EmptyList -&gt; ValueMatcher.EmptyList&lt;T&gt;()\n        is ValueMatcher.NotEmptyList -&gt; ValueMatcher.NotEmptyList&lt;T&gt;()\n        is ValueMatcher.Equal -&gt; ValueMatcher.Equal&lt;T&gt;(value)\n        is ValueMatcher.NotEqual -&gt; ValueMatcher.NotEqual&lt;T&gt;(value)\n    }</code>\n        </deckgo-highlight-code>\n<p>abstract를 사용하는 경우 다른 개발자가 새로운 인스턴스를 만들어 사용할 수 있다. 이러한 경우는 함수를 abstract로 선언하고 서브클래스 내부에 구현해야 한다. when을 사용하면 프로젝트 외부에서 새로운 클래스가 추가될 때 함수가 제대로 동작하지 않을 수 있기 때문이다.</p>\n<p>클래스의 서브 클래스를 제어하려면 sealed 한정자를 사용하고 abstract는 상속과 관련된 설계를 할 때 사용한다.</p>\n<h2 id=\"태그-클래스와-상태-패턴의-차이\" style=\"position:relative;\"><a href=\"#%ED%83%9C%EA%B7%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"태그 클래스와 상태 패턴의 차이 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>태그 클래스와 상태 패턴의 차이</h2>\n<p>태그 클래스와 상태 패턴(state pattern)을 혼동하면 안된다. 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.</p>\n<p>상태 패턴을 사용하면, 서로 다른 상태를 나타내는 클래스 계층 구조를 만들게 된다. 그리고 현재 상태를 나타내기 위한 읽고 쓸 수 있는 프로퍼티도 만들게 된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">sealed class WorkoutState\n\nclass PrepareState(val exercise: Exercise) : WorkoutState()\nclass ExerciseState(val exercise: Exercise) : WorkoutState()\nobject DoneState : WorkoutState()\n\nfun List&lt;Exercise&gt;.toStates(): List&lt;WorkoutState&gt; = \n    flatMap { exercise -&gt; \n        listOf(PrepareState(exercise), ExerciseState(exercise))\n    } + DoneState\n\nclass WorkoutPresenter( /*...*/ ) {\n    private var state: WorkoutState = states.first()\n    \n    // ...\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 차이점은 다음과 같다.</p>\n<ul>\n<li>상태는 더 많은 책임을 가진 클래스이다.</li>\n<li>상태는 변경할 수 있다.</li>\n</ul>\n<p>구체적인 상태(concreate state)는 객체를 활용해 표현하는 것이 일반적이며, 태그 클래스 보다는 sealed 클래스 계층으로 만든다. 또한 이를 immutable 객체로 만들고, 변경해야 할 때 마다 state 프로퍼티를 변경하게 만든다. 그리고 뷰에서 이런 state의 변화를 관찰(observe)한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">private var state: WorkoutState by\n    Delegates.observabled(states.first()) { _, _, _ -&gt;\n        updateView()\n    }</code>\n        </deckgo-highlight-code>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>코틀린에서는 태그 클래스보다 타입 계층을 사용하는 것이 좋다.</p>\n<p>그리고 이런 타입 계층을 만들 때는 sealed 클래스를 사용한다. 이는 상태 패턴과 다르다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-39/#sealed-%ED%95%9C%EC%A0%95%EC%9E%90\">sealed 한정자</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-39/#%ED%83%9C%EA%B7%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4\">태그 클래스와 상태 패턴의 차이</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-39/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-39/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-39","tagSlugs":null},"frontmatter":{"date":"2022-03-26T00:00:00.000Z","description":"Effective Kotlin Item 39. 태그 클래스보다는 클래스 계층을 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 39. 태그 클래스보다는 클래스 계층을 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-39"}},"staticQueryHashes":["2067870509","251939775","401334301"]}