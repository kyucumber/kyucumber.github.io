{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-24","result":{"data":{"markdownRemark":{"id":"411a9b6b-7254-59fc-9354-7295d17ab155","html":"<h2 id=\"invariant\" style=\"position:relative;\"><a href=\"#invariant\" aria-label=\"invariant permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>invariant</h2>\n<p>variacne 한정자(out 또는 in)이 없는 경우 invariant(불공변성)는 제네릭 타입으로 만들어지는 타입들이 서로 관련성이 없다는 의미이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Cup&lt;T&gt;\n\n// 아래 세가지 다 독립적이며 어떠한 관련성도 없다.\nval intCup: Cup&lt;Int&gt;\nval intCup: Cup&lt;Any&gt;\nval intCup: Cup&lt;Nothing&gt;</code>\n        </deckgo-highlight-code>\n<h2 id=\"variance\" style=\"position:relative;\"><a href=\"#variance\" aria-label=\"variance permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>variance</h2>\n<p>제네릭 타입 간 관련성을 가지길 원한다면 out 또는 in이라는 variance 한정자를 붙일 수 있다.</p>\n<h3 id=\"covariant공변성과-out-한정자\" style=\"position:relative;\"><a href=\"#covariant%EA%B3%B5%EB%B3%80%EC%84%B1%EA%B3%BC-out-%ED%95%9C%EC%A0%95%EC%9E%90\" aria-label=\"covariant공변성과 out 한정자 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>covariant(공변성)과 out 한정자</h3>\n<p>out은 타입 파라미터를 covariant(공변성)으로 만든다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Cup&lt;out T&gt;\n\nopen class Dog\nclass Puppy: Dog()\n\nval b: Cup&lt;Dog&gt; = Cup&lt;Puppy&gt;() // OK\nval a: Cup&lt;Puppy&gt; = Cup&lt;Dog&gt;() // 오류</code>\n        </deckgo-highlight-code>\n<p>A가 B의 서브타입일 때 <code class=\"language-text\">Cup&lt;A></code>가 <code class=\"language-text\">Cup&lt;B></code>의 서브타입이라는 의미, 위에서는 <code class=\"language-text\">Cup&lt;Dog></code>에 서브타입인 <code class=\"language-text\">Cup&lt;Puppy></code>가 할당될 수 있다.</p>\n<h3 id=\"contravariant반변성과-in-한정자\" style=\"position:relative;\"><a href=\"#contravariant%EB%B0%98%EB%B3%80%EC%84%B1%EA%B3%BC-in-%ED%95%9C%EC%A0%95%EC%9E%90\" aria-label=\"contravariant반변성과 in 한정자 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>contravariant(반변성)과 in 한정자</h3>\n<p>in은 out과 반대 의미이다. in 한정자는 타입 파라미터를 contravariant(반변성)으로 만든다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Cup&lt;in T&gt;\n\nopen class Dog\nclass Puppy: Dog()\n\nval b: Cup&lt;Dog&gt; = Cup&lt;Puppy&gt;() // 오류\nval a: Cup&lt;Puppy&gt; = Cup&lt;Dog&gt;() // OK</code>\n        </deckgo-highlight-code>\n<p>A가 B의 서브타입일 때 <code class=\"language-text\">Cup&lt;A></code>가 <code class=\"language-text\">Cup&lt;B></code>의 슈퍼타입이라는 의미, 위에서는 <code class=\"language-text\">Cup&lt;Puppy></code>에 슈퍼타입인 <code class=\"language-text\">Cup&lt;Dog></code>가 할당될 수 있다.</p>\n<p>variance 한정자를 그림으로 나타내면 다음과 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/85d7a3ed02198d80267995ad134e40cf/1790f/item-24-variance.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.583333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVQoz3WRW0sCURSF/XdBNw0z0kpLg6B6MKqH+gOB0IMk/pjMkMrExjELm0HUxvuDKTmjOd5XszekvrThwJm91nz7rHNMk8kE/9VoNMJ4PJ5+k5d68/r8goEykTAcDqHrOnq93vSHWq2KeDyGfD6HP48sS0gkBBSLBe41mw0IwguSSRHlcol7DAwGb7Dr2saWw4ZwOMTC5cU53Hs72Pc4UamUeYDH2HvcLpydetkTjT7CvrkOl9OBQMA/A5I59vwEURTQan2zUFAUY3oc6fQ7n3wwGCCTkQ3IAxTlk+Nrqoq3VBKpVxHVamUGVA0hl8uiVCpydKpG4wuS/MFR6BooMg0maL1eZ2C/30c2m4EkpZkxBfr917BYlrCyvIC70C0LJ95jvoIN2xoPIpjDbuOIR4cH7IlE7mFeXYTVaobPdzUD6noXmqbyomhUP50OR6Le32u32220NY01KvKqaotP1+12ufcL2cPss3h98w8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/85d7a3ed02198d80267995ad134e40cf/8ac56/item-24-variance.webp 240w,\n/static/85d7a3ed02198d80267995ad134e40cf/d3be9/item-24-variance.webp 480w,\n/static/85d7a3ed02198d80267995ad134e40cf/e46b2/item-24-variance.webp 960w,\n/static/85d7a3ed02198d80267995ad134e40cf/1671b/item-24-variance.webp 1189w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/85d7a3ed02198d80267995ad134e40cf/8ff5a/item-24-variance.png 240w,\n/static/85d7a3ed02198d80267995ad134e40cf/e85cb/item-24-variance.png 480w,\n/static/85d7a3ed02198d80267995ad134e40cf/d9199/item-24-variance.png 960w,\n/static/85d7a3ed02198d80267995ad134e40cf/1790f/item-24-variance.png 1189w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/85d7a3ed02198d80267995ad134e40cf/d9199/item-24-variance.png\"\n            alt=\"item-24-variance.png\"\n            title=\"item-24-variance.png\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h2 id=\"함수-타입\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85\" aria-label=\"함수 타입 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 타입</h2>\n<p>함수 타입은 파라미터 유형과 리턴 타입에 따라 서로 관계를 갖는다.</p>\n<p>(Int) → Any 타입의 함수는 다음과 같은 타입 등으로도 동작한다.</p>\n<ul>\n<li>(Int) → Number</li>\n<li>(Number) → Any</li>\n<li>(Number) → Number</li>\n<li>(Number) → Int</li>\n</ul>\n<p>이는 아래와 같은 관계에 의해서 가능하다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7a3a6858329f824f22e3efff55cdc19c/3096d/item-24-function-type.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8klEQVQoz31SWxKDMAj0/sesH9Uan4mPqJFmcahUHZlhQIGFhSTbthEEVquIc4763rGdpukxF34izllCCLSuKw3DQNZ2EbSncRz531k0cCLOsiy/ImMMTwNQ3RAWgHVdUdM0NM8zN/ybUJIRxCTOWcqyd/z2FzDx0dCYgptaa/9yLpSPBp6bHLvCCpYIMqr87dI0eToK6BTFh4+y06xPuWcGdEyogcQCqCwL6rp2B4wawvqLY8eY/JayTsKBvPeXi6LY+4njiAnYLWUsuKpKvnSavhjwbnpInmdRc65p2/YecJ9sZgsw/WRkV/pFQIWNjn0BkWYUbcXEvUYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/7a3a6858329f824f22e3efff55cdc19c/8ac56/item-24-function-type.webp 240w,\n/static/7a3a6858329f824f22e3efff55cdc19c/d3be9/item-24-function-type.webp 480w,\n/static/7a3a6858329f824f22e3efff55cdc19c/e46b2/item-24-function-type.webp 960w,\n/static/7a3a6858329f824f22e3efff55cdc19c/b2f3f/item-24-function-type.webp 1319w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/7a3a6858329f824f22e3efff55cdc19c/8ff5a/item-24-function-type.png 240w,\n/static/7a3a6858329f824f22e3efff55cdc19c/e85cb/item-24-function-type.png 480w,\n/static/7a3a6858329f824f22e3efff55cdc19c/d9199/item-24-function-type.png 960w,\n/static/7a3a6858329f824f22e3efff55cdc19c/3096d/item-24-function-type.png 1319w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/7a3a6858329f824f22e3efff55cdc19c/d9199/item-24-function-type.png\"\n            alt=\"item-24-variance.png\"\n            title=\"item-24-variance.png\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>파라미터 타입은 Int → Number → Any로 높은 타입으로 이동하며, 리턴 타입은 Any → Number → Int로 낮은 타입으로 이동한다.</p>\n<p>코틀린의 <strong>함수 타입의 모든 파라미터 타입은 contravariant(in 한정자)이며 모든 리턴 타입은 covariant(out 한정자)</strong>이다.</p>\n<p>함수 타입을 사용할때는 이처럼 자동으로 variance 한정자가 사용되며, 코틀린에서 자주 사용되는 것으로는 covariant(out 한정자)를 가진 List가 존재한다.</p>\n<h2 id=\"variance-한정자의-안정성\" style=\"position:relative;\"><a href=\"#variance-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EC%95%88%EC%A0%95%EC%84%B1\" aria-label=\"variance 한정자의 안정성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>variance 한정자의 안정성</h2>\n<p>자바의 배열은 covariant이며 이로 인해 아래와 같은 문제가 발생할 수 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">Integer[] numbers = {1, 4, 2, 1};\nObject[] objects = numbers;\nobjects[2] = &quot;B&quot; // 오류</code>\n        </deckgo-highlight-code>\n<p>위는 컴파일 타임 중에는 아무 문제가 없지만 런타임 오류가 발생한다.</p>\n<p>코틀린은 이러한 결함을 해결하기 위해 Array를 invariant(IntArray, CharArray, ByteArray 등) 만들었으며, <code class=\"language-text\">Array&lt;Int></code>를 <code class=\"language-text\">Array&lt;Any></code> 등으로 바꿀 수 없다.</p>\n<h3 id=\"covariant-타입-파라미터와-함수-타입의-파라미터\" style=\"position:relative;\"><a href=\"#covariant-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\" aria-label=\"covariant 타입 파라미터와 함수 타입의 파라미터 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>covariant 타입 파라미터와 함수 타입의 파라미터</h3>\n<p>아래 코드는 covariant하지 않다.  <strong>covariant 타입 파라미터(out)가 in 한정자 위치(함수의 타입 파라미터)에 있다면 covariant(out)와 업캐스팅을 연결해서 우리가 원하는 타입을 아무것이나 전달</strong>할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">open class Dog\nclass Puppy: Dog()\nclass Hound: Dog()\n\nfun takeDog(dog: Dog) {}\n\nfun main() {\n    takeDog(Dog())\n    takeDog(Puppy())\n    takeDog(Hound())\n}\n\nclass Box&lt;out T&gt; {\n    private var value: T? = null\n\n    // Type parameter T is declared as &#39;out&#39; but occurs in &#39;in&#39; position in type T\n    fun set(value: T) {\n        this.value = value\n    }\n\n    fun get(): T = value ?: error(&quot;Value not set&quot;)\n}\n\nfun main() {\n    val puppyBox = Box&lt;Puppy&gt;()\n    val dogBox: Box&lt;Dog&gt; = puppyBox\n\n    dogBox.set(Hound()) // Puppy를 위한 Box지만 Hound를 set 함수에 전달할 수 있다.\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같은 행위가 가능하다면 오류가 발생할 것이므로 코틀린은 <strong>public in 한정자 위치(함수의 타입 파라미터)에 covariant 타입 파라미터(out)가 오는 것을 금지해 이런 오류를 사전에 방지</strong>한다.</p>\n<blockquote>\n<p>주석에도 표시해 뒀지만, 위와 같이 클래스를 정의하면 아래와 같은 에러 메시지가 노출된다.</p>\n<p>Type parameter T is declared as ‘out’ but occurs in ‘in’ position in type T</p>\n</blockquote>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Box&lt;out T&gt; {\n    private var value: T? = null\n\n    private fun set(value: T) {\n        this.value = value\n    }\n\n    fun get(): T = value ?: error(&quot;Value not set&quot;)\n}</code>\n        </deckgo-highlight-code>\n<p>private으로 제한하면 오류가 발생하지 않는다. get 메소드의 리턴 타입에 T가 사용되는데 covariant(out 한정자)는 public out 한정자 위치에도 안전하므로 이는 따로 제한되지 않는다.</p>\n<p>위와 같은 covariant는 Producer나 Immutable 데이터 홀더에 많이 사용되며 아래 <code class=\"language-text\">List&lt;T></code>도 covariant의 형태를 띄고 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">public interface List&lt;out E&gt; : Collection&lt;E&gt; {</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">MutableList&lt;T></code>의 T는 in 한정자 위치(함수의 타입 파라미터)에서 사용되며 안전하지 않으므로 invariant로 제공된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; {</code>\n        </deckgo-highlight-code>\n<p>이외에 좋은 예로는 Response가 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">sealed class Response&lt;out R, out E&gt;\nclass Failure&lt;out E&gt;(val error: E): Response&lt;Nothing, E&gt;()\nclass Success&lt;out R&gt;(val value: R): Response&lt;R, Nothing&gt;()</code>\n        </deckgo-highlight-code>\n<p>covariant와 Nothing 타입으로 인해 Failure는 오류 타입을 지정하지 않아도 되고, Success는 잠재적인 값을 지정하지 않아도 된다.</p>\n<h3 id=\"contravariant-타입-파라미터와-함수-리턴-타입-클래스의-프로퍼티-타입\" style=\"position:relative;\"><a href=\"#contravariant-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B4-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%83%80%EC%9E%85\" aria-label=\"contravariant 타입 파라미터와 함수 리턴 타입 클래스의 프로퍼티 타입 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>contravariant 타입 파라미터와 함수 리턴 타입, 클래스의 프로퍼티 타입</h3>\n<p>contravariant 타입 파라미터(in)와 public out 위치(함수 리턴 타입 또는 클래스의 프로퍼티 타입)에서도 문제가 발생할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">open class Car\ninterface Boat\nclass Amphibious: Car(), Boat\n\nfun getAmphibious(): Amphibious = Amphibious()\n\nclass Box&lt;in T&gt;(\n    // Type parameter T is declared as &#39;in&#39; but occurs in &#39;out&#39; position in type T\n    val value: T\n)\n\nfun main() {\n    val garage: Box&lt;Car&gt; = Box(Car())\n    val amphibious: Box&lt;Amphibious&gt; = garage\n    val boat: Boat = amphibious.value // 실제로는 Car를 위한 Box이다.\n\n    // 책에는 garage.value로 되어있는데 조금 이상해서 수정했습니다.\n}</code>\n        </deckgo-highlight-code>\n<p>Box에 어떤 타입이 들어있는지 확실하게 알수가 없다.</p>\n<blockquote>\n<p>value에 T 타입을 지정하면 아래와 같은 에러 메시지가 노출된다.</p>\n<p>Type parameter T is declared as ‘in’ but occurs in ‘out’ position in type T</p>\n</blockquote>\n<p>이러한 상황을 막기 위해 코틀린은 <strong>contravariant 타입 파라미터(in)을 public out 한정자 위치(함수 리턴 타입, 클래스의 프로퍼티 타입)위치에 사용하는것을 금지</strong>하고 있다.</p>\n<p>물론 이번에도 아래처럼 private로 지정하면 아무런 문제가 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Box&lt;in T&gt;(\n    private val value: T\n)</code>\n        </deckgo-highlight-code>\n<p>contravariant를 사용하는 예로는 <code class=\"language-text\">kotlin.coroutine.Continuation</code> 이 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">public interface Continuation&lt;in T&gt; {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result&lt;T&gt;)\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"variance-한정자의-위치\" style=\"position:relative;\"><a href=\"#variance-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EC%9C%84%EC%B9%98\" aria-label=\"variance 한정자의 위치 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>variance 한정자의 위치</h2>\n<p>variance 한정자는 선언 부분과 클래스 인터페이스를 활용하는 위치에 사용할 수 있다.</p>\n<ul>\n<li>\n<p>선언 부분</p>\n<p>일반적으로 이 위치에 사용하며, 클래스와 인터페이스가 사용되는 모든 곳에 영향을 준다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">// 선언 쪽의 variance 한정자\nclass Box&lt;out T&gt;(val value: T)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>클래스와 인터페이스를 활용하는 위치</p>\n<p>이 위치에  variance를 적용하면 특정 변수에만 variance 한정자가 적용된다. 특정 인스턴스에만 적용해야 하는 경우 사용한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Box&lt;T&gt;(val value: T)\n\n// 사용하는 쪽의 variance 한정자\nval boxAny: Box&lt;out Any&gt; = boxStr</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>MutableList에 in 한정자를 포함하면 요소의 리턴이 불가능하므로 붙이지 않는다.</p>\n<p>하지만 여러 타입을 받아들이게 하기 위해 아래와 같이 단일 파라미터 타입에 in을 붙여 활용할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">interface Dog\ninterface Cutie\n\ndata class Puppy(val name: String): Dog, Cutie\ndata class Hound(val name: String): Dog\ndata class Cat(val name: String): Cutie\n\nfun fillWithPuppies(list: MutableList&lt;in Puppy&gt;) {\n    list.add(Puppy(&quot;One&quot;))\n    list.add(Puppy(&quot;Two&quot;))\n}\n\nfun main() {\n    val dogs = mutableListOf&lt;Dog&gt;(Hound(&quot;Pluto&quot;))\n    fillWithPuppies(dogs)\n\n    val cats = mutableListOf&lt;Cutie&gt;(Cat(&quot;Pluto&quot;))\n    fillWithPuppies(cats)\n}</code>\n        </deckgo-highlight-code>\n<p>variance 한정자를 사용하면 아래처럼 제한이 있을 수 있다.</p>\n<p><code class=\"language-text\">MutableList&lt;out T></code> get() 요소 추출 시 T 타입이 리턴되지만 set은 Nothing 타입의 아규먼트가 전달될 수도 있을것으로 예상되므로 사용할 수 없다.</p>\n<p><code class=\"language-text\">MutableList&lt;in T></code> 사용 시 get과 set을 모두 사용할 수 있지만 get()을 사용할 경우 Any?가 리턴된다. 이는 슈퍼타입을 가진 리스트가 존재할 가능성이 있기 때문이다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>코틀린은 강력한 제네릭 기능을 제공하며 아래와 같은 타입 한정자가 존재한다.</p>\n<ul>\n<li>기본적인 variance의 동작은 invariant이다. <code class=\"language-text\">Cup&lt;A></code>와 <code class=\"language-text\">Cup&lt;B></code>는 기본적으로는 아무런 관계를 갖지 않는다.</li>\n<li>out 한정자는 타입 파라미터를 covariant하게 만든다. covariant 타입은 out 위치에 사용할 수 있다.</li>\n<li>in 한정자는 타입 파라미터를 contravariant하게 만든다. contravariant 타입은 in 위치에 사용할 수 있다.</li>\n<li>List, Set의 타입 파라미터는 covariant(out) 이다.</li>\n<li>Array, MutableList, MutableSet의 타입 파라미터는 invaraint이다.</li>\n<li>함수 타입의 파라미터 타입은 contravariant(in)이다.</li>\n<li>리턴 타입의 파라미터 타입은 covariant(out) 이다. <strong><em>책에는 contravariant로 되어 있음 임의로 수정</em></strong></li>\n<li>리턴만 되는 타입에는 covariant(out)을 사용한다.</li>\n<li>허용만 되는 타입에는 contravariant(in)을 사용한다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#invariant\">invariant</a></li>\n<li>\n<p><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#variance\">variance</a></p>\n<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#covariant%EA%B3%B5%EB%B3%80%EC%84%B1%EA%B3%BC-out-%ED%95%9C%EC%A0%95%EC%9E%90\">covariant(공변성)과 out 한정자</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#contravariant%EB%B0%98%EB%B3%80%EC%84%B1%EA%B3%BC-in-%ED%95%9C%EC%A0%95%EC%9E%90\">contravariant(반변성)과 in 한정자</a></li>\n</ul>\n</li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85\">함수 타입</a></li>\n<li>\n<p><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#variance-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EC%95%88%EC%A0%95%EC%84%B1\">variance 한정자의 안정성</a></p>\n<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#covariant-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0\">covariant 타입 파라미터와 함수 타입의 파라미터</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#contravariant-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B4-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%83%80%EC%9E%85\">contravariant 타입 파라미터와 함수 리턴 타입, 클래스의 프로퍼티 타입</a></li>\n</ul>\n</li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#variance-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EC%9C%84%EC%B9%98\">variance 한정자의 위치</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-24/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-24","tagSlugs":null},"frontmatter":{"date":"2022-02-27T00:05:00.000Z","description":"Effective Kotlin Item24. 제네릭 타입과 variance 한정자를 활용하라","tags":null,"title":"이펙티브 코틀린 아이템 24. 제네릭 타입과 variance 한정자를 활용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-24"}},"staticQueryHashes":["2067870509","251939775","401334301"]}