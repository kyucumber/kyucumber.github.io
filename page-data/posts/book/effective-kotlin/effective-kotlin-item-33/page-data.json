{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-33","result":{"data":{"markdownRemark":{"id":"202a6ed0-176e-55ed-b5ca-3c26451f61d7","html":"<p>클라이언트가 클래스의 인스턴스를 만들게 하는 가장 일반적인 방법은 기본 생성자를 사용하는 방법이다. 생성자가 객체를 만들 수 있는 유일한 방법은 아니며 굉장히 다양한 생성 패턴이 만들어져 있다.</p>\n<p>생성자의 역할을 대신 해주는 함수를 <strong>팩토리 함수</strong>라고 부른다. 생성자 대신 팩토리 함수를 사용하면 아래와 같은 장점이 생긴다.</p>\n<ul>\n<li>생성자와 다르게 함수에 이름을 붙일 수 있다. 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지 이름으로 설명할 수 있다.</li>\n<li>생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다.</li>\n<li>생성자와 다르게 호출될 때마다 새로운 객체를 만들 필요가 없다. 싱글턴 패턴처럼 객체를 하나만 생성하게 강제하거나 캐싱 메커니즘을 사용할 수도 있다.</li>\n<li>팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있다. 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있다.</li>\n<li>객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있다.</li>\n<li>팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.</li>\n<li>팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있다.</li>\n<li>생성자는 슈퍼클래스 또는 기본 생성자를 호출해야 하지만 팩토리 함수를 사용하면 원하는 때에 생성자를 호출할 수 있다.</li>\n</ul>\n<p>위와 같은 장점이 있다고 해서 팩토리 함수를 사용하고 기본 생성자를 사용하지 말라는 것은 아니다.\n팩토리 함수 내부에서는 생성자를 사용해야 한다.</p>\n<p>팩토리 함수는 기본 생성자가 아닌 secondary constructor와 경쟁 관계이다.</p>\n<p>팩토리 함수를 정의하는 방법은 아래와 같다.</p>\n<ul>\n<li>companion 객체 팩토리 함수</li>\n<li>확장 팩토리 함수</li>\n<li>톱레벨 팩토리 함수</li>\n<li>가짜 생성자</li>\n<li>팩토리 클래스의 메소드</li>\n</ul>\n<h2 id=\"companion-객체-팩토리-함수\" style=\"position:relative;\"><a href=\"#companion-%EA%B0%9D%EC%B2%B4-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\" aria-label=\"companion 객체 팩토리 함수 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>companion 객체 팩토리 함수</h2>\n<p>팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것이다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">class MyLinkedList&lt;T&gt;(\n    val head: T,\n    val tail: MyLinkedList&lt;T&gt;\n) {\n    compaion object {\n        fun &lt;T&gt; of(vararg elements: T): MyLinkedList&lt;T&gt; {\n            // ...\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이러한 접근 방법은 인터페이스에도 구현할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">class MyLinkedList&lt;T&gt;(\n    val head: T,\n    val tail: MyLinkedList&lt;T&gt;\n) {\n    // ...\n}\n\ninterface MyList {\n    // ...\n\n    compaion object {\n        fun &lt;T&gt; of(vararg elements: T): MyyhList&lt;T&gt; {\n            // ...\n        }\n    }\n}\n\nval list = MyList.of(1, 2)</code>\n        </deckgo-highlight-code>\n<p>팩토리 함수의 네이밍에는 아래와 같은 이름들이 많이 사용된다.</p>\n<ul>\n<li>\n<p>from: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val date: Date = Date.from(instant)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>of: 파라미터를 여러개 받고, 이를 통합해 인스턴스를 만들어주는 함수</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val faceCards: Set&lt;Rank&gt; = EnumSet.of(JACK, QUEEN, KING)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>valueOf: from 또는 of와 비슷한 기능을 하면서도 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val prime: BigInteger = BigInteger.valueOf(Integer.MAX_VALUE)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>instance, getInstance: 싱글턴으로 인스턴스 하나를 리턴하는 함수</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val luke: StackWalker = StackWalker.getInstance(options)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>createInstance, newInstance: getInstance처럼 동작하지만 싱글턴이 적용되지 않아서 호출할 때 마다 새로운 인스턴스를 만들어서 리턴</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val newArray = Array.newInstance(classObject, arrayLen)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>getType: getInstance처럼 동작하지만 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val fs: FileStore = Files.getFileStore(path)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>newType: newInstance처럼 동작하지만 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">val br: BufferedReader = Files.newBufferedReader(path)</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>경험이 없는 코틀린 개발자들은 companion 객체 멤버를 단순한 정적 멤버처럼 다루는 경우가 많다. 하지만 companion 객체는 더 많은 기능을 가진다. 인터페이스를 구현하거나 클래스를 상속받을 수 있다.</p>\n<p>예를 들어 코틀린의 코루틴 내부에서는 코루틴 컨텍스트의 companion 객체들이 CoroutineContext.Key의 인터페이스를 구현하고 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">public interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"확장-팩토리-함수\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\" aria-label=\"확장 팩토리 함수 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 팩토리 함수</h2>\n<p>이미 companion 객체가 존재할 때, companion 객체를 직접 수정할 수는 없고 다른 파일에 함수를 만들어야 한다면 확장 함수를 활용하면 된다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">fun Tool.Companion.createBigTool( /*...*/ ) : BigTool {\n    // ...\n}\n\n// 사용\nTool.createBigTool()</code>\n        </deckgo-highlight-code>\n<h2 id=\"톱레벨-팩토리-함수\" style=\"position:relative;\"><a href=\"#%ED%86%B1%EB%A0%88%EB%B2%A8-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\" aria-label=\"톱레벨 팩토리 함수 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>톱레벨 팩토리 함수</h2>\n<p>객체를 만드는 흔한 방법 중 하나로 listOf, setOf, mapOf 등과 같은 톱레벨 팩토리 함수를 이용하는 방법이 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">listOf(1, 2, 3)</code>\n        </deckgo-highlight-code>\n<p>public 톱레벨 함수는 모든 곳에서 사용할 수 있으므로 IDE의 팁을 복잡하게 만드는 단점이 있다. 따라서 톱레벨 함수를 만들 때는 이름을 신중하게 잘 지정해야 한다.</p>\n<h2 id=\"가짜-생성자\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%A7%9C-%EC%83%9D%EC%84%B1%EC%9E%90\" aria-label=\"가짜 생성자 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가짜 생성자</h2>\n<p>코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용된다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">class A\nval a = A()</code>\n        </deckgo-highlight-code>\n<p>아래와 같은 톱레벨 함수는 생성자 처럼 보이고 생성자 처럼 작동한다. 하지만 팩토리 함수와 같은 모든 장점을 갖는다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">public inline fun &lt;T&gt; List(\n    size: Int,\n    init: (index: Int) -&gt; T\n): List&lt;T&gt; = MutableList(size, init)</code>\n        </deckgo-highlight-code>\n<p>많은 개발자들이 이를 톱레벨 함수인지 잘 모르며, 이를 가짜 생성자(Fake Constructor)라고 부른다.</p>\n<p>생성자 대신 가짜 생성자를 만드는 이유는 다음과 같다.</p>\n<ul>\n<li>인터페이스를 위한 생성자를 만들고 싶을 때</li>\n<li>reified 타입 아규먼트를 갖게 하고 싶을 때</li>\n</ul>\n<p>가짜 생성자를 선언하기 위해 invoke 연산자를 갖는 companion 객체를 사용할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">class Tree&lt;T&gt; {\n    companion object {\n        operator fun &lt;T&gt; invoke(size: Int, generator: (Int) -&gt; T): Tree &lt;T&gt;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이는 거의 사용되지 않으며 아이템 12. <strong>연산자 오버로드를 할 때는</strong> <strong>의미에 맞게 하라는 원칙에 위배</strong>되기 때문에 추천하지 않는다.</p>\n<h2 id=\"팩토리-클래스의-메소드\" style=\"position:relative;\"><a href=\"#%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"팩토리 클래스의 메소드 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>팩토리 클래스의 메소드</h2>\n<p>팩토리 클래스와 관련된 추상 팩토리, 프로토타입 등의 수많은 생성 패턴이 있다.</p>\n<p>이런 패턴 중 일부는 코틀린에서는 적합하지 않다. 점층적 생성자 패턴과 빌더 패턴은 코틀린에서는 의미가 없다.</p>\n<p>아래는 nextId를 갖는 학생을 생성하는 팩토리 클래스이다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"dracula\" >\n          <code slot=\"code\">data class Student(\n    val id: Int,\n    val name: String,\n    val surname: String\n)\n\nclass StudentsFactory {\n    var nextId = 0\n    fun next(name: String, surname: String) = Student(nextId++. name, surname)\n}</code>\n        </deckgo-highlight-code>\n<p>팩토리 클래스는 프로퍼티를 가질 수 있으며 이를 활용해 다양하게 최적화하거나 기능을 가질 수 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>코틀린은 팩토리 함수를 만들 수 있는 다양한 방법들을 제공하며 각각의 방법들은 여러 특징을 갖고 있다.</p>\n<p>객체를 생성할때는 이런 특징을 잘 파악하고 사용해야 한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#companion-%EA%B0%9D%EC%B2%B4-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\">companion 객체 팩토리 함수</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#%ED%99%95%EC%9E%A5-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\">확장 팩토리 함수</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#%ED%86%B1%EB%A0%88%EB%B2%A8-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%95%A8%EC%88%98\">톱레벨 팩토리 함수</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#%EA%B0%80%EC%A7%9C-%EC%83%9D%EC%84%B1%EC%9E%90\">가짜 생성자</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C\">팩토리 클래스의 메소드</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-33/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-33","tagSlugs":null},"frontmatter":{"date":"2022-03-06T00:04:00.000Z","description":"Effective Kotlin Item 33. 생성자 대신 팩토리 함수를 사용하라","tags":null,"title":"이펙티브 코틀린 아이템 33. 생성자 대신 팩토리 함수를 사용하라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-33"}},"staticQueryHashes":["2067870509","251939775","401334301"]}