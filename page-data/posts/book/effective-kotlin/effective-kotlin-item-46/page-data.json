{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-46","result":{"data":{"markdownRemark":{"id":"b06ef6e0-3196-5343-8546-31aeb658c450","html":"<p>코틀린 표준 라이브러리의 고차 함수(high order function)을 살펴보면 대부분 inline 한정자가 붙어있는 것을 확인할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun repeat(times: Int, action: (Int) -&gt; Unit) {\n    for (index in 0 until times) {\n        action(index)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>inline 한정자의 역할은 컴파일 시점에 함수를 호출하는 부분을 함수의 본문으로 대체하는 것이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">repeat(10) {\n    print(it)\n}\n\n// 컴파일 시점에 아래와 같이 대체된다.\nfor (index in 0 until 10) {\n    print(index)\n}</code>\n        </deckgo-highlight-code>\n<p>위처럼 inline 한정자를 붙여 함수를 만들면 큰 변화가 일어난다. </p>\n<p>일반적인 함수를 호출하면 함수 본문으로 점프하고, 본문의 모든 문장을 뒤에 호출했던 위치로 점프하는 과정을 거친다.</p>\n<p>하지만 <strong>inline 한정자를 사용해 함수를 호출하는 부분을 함수의 본문으로 대체하면 이러한 점프가 일어나지 않는다</strong>.</p>\n<p>inline 한정자를 사용하면 다음과 같은 장점이 있다.</p>\n<ul>\n<li>타입 아규먼트에 reified 한정자를 붙여서 사용할 수 있다.</li>\n<li>함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.</li>\n<li>비 지역(non-local) 리턴을 사용할 수 있다.</li>\n</ul>\n<p>장점만 있는 것은 아니며, 분명 단점도 존재한다. 이는 아래의 inline 한정자의 비용에서 살펴볼 것이다.</p>\n<h2 id=\"타입-아규먼트를-reified로-사용할-수-있다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-reified%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"타입 아규먼트를 reified로 사용할 수 있다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 아규먼트를 reified로 사용할 수 있다.</h2>\n<p>JVM 바이트 코드 내부에는 제네릭이 존재하지 않아 컴파일을 하면 제네릭 타입과 관련된 내용이 제거된다.</p>\n<p>그래서 객체가 List인지 확인은 할 수 있어도 <code class=\"language-text\">List&lt;Int></code>인지 확인하는 코드는 사용할 수 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">any is List&lt;Int&gt; // 오류\nany is List&lt;*&gt; // OK</code>\n        </deckgo-highlight-code>\n<p>같은 이유로 다음과 같은 타입 파라미터에 대한 연산도 오류가 발생한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun &lt;T&gt; printTypeName() {\n    print(T::class.simpleName) // 오류\n}</code>\n        </deckgo-highlight-code>\n<p>함수를 인라인으로 만들면 이러한 제한을 무시할 수 있다. 함수 호출이 본문으로 대체되므로 reified 한정자를 지정하면 <strong>타입 파라미터를 사용한 부분이 타입 아규먼트로 대체</strong>된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun &lt;reified T&gt; printTypeName2() {\n    print(T::class.simpleName)\n}\n\n// 사용\nprinttypeName&lt;Int&gt;()\nprinttypeName&lt;Char&gt;()\nprinttypeName&lt;String&gt;()</code>\n        </deckgo-highlight-code>\n<p>컴파일하는 동안 printTypeName의 본문이 실제로 대체되므로 실제로는 아래와 같이 된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">print(Int::class.simpleName)\nprint(Char::class.simpleName)\nprint(String::class.simpleName)</code>\n        </deckgo-highlight-code>\n<p>reified는 굉장히 유용한 한정자이며 표준 라이브러리인 filterIsInstance에서도 활용된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">class Worker\nclass Manager\n    \nval workers: List&lt;Worker&gt; = employees.filterIsInstance&lt;Worker&gt;()\n\npublic inline fun &lt;reified R&gt; Iterable&lt;*&gt;.filterIsInstance(): List&lt;@kotlin.internal.NoInfer R&gt; {\n    return filterIsInstanceTo(ArrayList&lt;R&gt;())\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"함수-타입-파라미터를-가진-함수가-훨씬-빠르게-동작한다\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A7%84-%ED%95%A8%EC%88%98%EA%B0%80-%ED%9B%A8%EC%94%AC-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%9C%EB%8B%A4\" aria-label=\"함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.</h2>\n<p>모든 함수는 inline 한정자를 붙이면 조금 더 빠르게 동작한다. 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문이다.</p>\n<p>그래서 표준 라이브러리의 간단한 함수들에는 대부분 inline 한정자가 붙어있다.</p>\n<p>하지만 함수 파라미터를 가지지 않는 함수에는 이러한 차이가 큰 성능 차이를 발생시키지 않는다.</p>\n<p>코틀린 / JVM에서는 익명 클래스 또는 일반 클래스를 기반으로 함수를 객체로 만들어낸다. 따라서 아래와 같은 람다 표현식은 클래스로 컴파일된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">val lambda: () -&gt; Unit = {\n    // 코드\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>익명 클래스로 컴파일</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">Function0&lt;Unit&gt; lambda = new Function0&lt;Unit&gt;() {\n    public Unit invoke() {\n        // 코드\n    }\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>별도 파일의 일반 클래스로 컴파일</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">public class Test$lambda implements Function0&lt;Unit&gt; {\n    public Unit invoke() {\n        // 코드\n    }\n}\n\n// 사용\nFunction0 lambda = new Test$lambda()</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>두 결과 사이에 큰 차이는 없다.</p>\n<ul>\n<li>() → Unit은 Function0<Unit>으로 컴파일</li>\n<li>()  → Int는 Function0<Int>로 컴파일</li>\n<li>(Int) → Int는 Function1&#x3C;Int, Int>로 컴파일</li>\n<li>(Int, Int) → Int는 Function2&#x3C;Int, Int, Int>로 컴파일</li>\n</ul>\n<p>이러한 모든 인터페이스는 모두 코틀린 컴파일러에 의해 생성된다. 명시적으로 사용할 수는 없지만 대신 함수 타입을 사용할 수 있다.</p>\n<p>함수 본문을 객체로 랩(wrap)하면 코드의 속도가 느려지기 때문에 다음과 같은 두 함수가 있을 때 첫번째 함수가 더 빠르다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun repeat(times: Int, action: (Int) -&gt; Unit) {\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n\nfun repeatNoinline(times: Int, action: (Int) -&gt; Unit) {\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n\n// 평균 198ms 속도로 동작\n@Benchmark\nfun nothingInline(blackhole: Blackhole) {\n    repeat(100_000_000) {\n        blackhole.consume(it)\n    }\n}\n\n// 평균 477ms 속도로 동작\n@Benchmark\nfun repeatNoinline(blackhole: Blackhole) {\n    repeat(100_000_000) {\n        blackhole.consume(it)\n    }\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>첫번째 inline repeat 함수</p>\n<ul>\n<li>숫자로 반복을 돈다 → 빈 함수를 호출한다.</li>\n</ul>\n</li>\n<li>\n<p>두번째 repeatNoinline 함수</p>\n<ul>\n<li>숫자로 반복을 돈다 → 객체를 호출한다 → 객체가 빈 함수를 호출한다.</li>\n</ul>\n</li>\n</ul>\n<p>위와 같은 코드의 실행 방식 차이로 속도의 차이가 발생한다. 이는 큰 차이로 보이지 않을 수 있지만, 이러한 처리를 할 때 마다 시간이 계속 누적될 것이다.</p>\n<p>이외에 인라인 함수와 인라인 함수가 아닌 함수의 더 중요한 차이는 <strong>함수 리터럴 내부의 지역 변수를 캡처할 때 확인</strong>할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">var l = 1L\nnoinelineRepeat(100_000_000) {\n    l += it\n}</code>\n        </deckgo-highlight-code>\n<p>인라인이 아닌 람다 표현식에서는 지역 변수 l을 직접 사용하지 않고 컴파일 과정 중 아래와 같이 <strong>레퍼런스 객체로 래핑</strong>되고 람다 표현식 내부에서 이를 사용한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">var a = Ref.LongRef()\na.element = 1L\n\nnoinelineRepeat(100_000_000) {\n    a.element = a.element + it\n}</code>\n        </deckgo-highlight-code>\n<p>이는 실제로 중요한 차이를 발생시킨다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">// 평균 30ms 속도로 동작\n@Benchmark\nfun nothingInline(blackhole: Blackhole) {\n    var l = 0L\n    repeat(100_000_000) {\n        l += it\n    }\n    blackhole.consume(l)\n}\n\n// 평균 274ms 속도로 동작\n@Benchmark\nfun repeatNoinline(blackhole: Blackhole) {\n    var l = 0L\n    noinelineRepeat(100_000_000) {\n        l += it\n    }\n    blackhole.consume(l)\n}</code>\n        </deckgo-highlight-code>\n<p>이는 함수가 객체로 컴파일되고, 지역 변수가 래핑되어 발생하는 문제가 누적된 결과이다.</p>\n<p>일반적으로 함수 타입의 파라미터가 어떻게 동작하는지 이해하기 어려우므로 함수 타입 파라미터를 활용해 <strong>유틸리티 함수를 만들 때 그냥 인라인을 붙여준다고 단순히 생각</strong>하는 것도 좋다.</p>\n<h2 id=\"비지역적-리턴non-local-return을-사용할-수-있다\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%A7%80%EC%97%AD%EC%A0%81-%EB%A6%AC%ED%84%B4non-local-return%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"비지역적 리턴non local return을 사용할 수 있다 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비지역적 리턴(non-local return)을 사용할 수 있다.</h2>\n<p>이전에 작성한 repeatNoinline은 내부에서 리턴을 사용할 수 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun repeatNoinline(times: Int, action: (Int) -&gt; Unit) {\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n\nfun main() {\n    repeatNoinline(10) {\n        print(it)\n        return // 오류\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이는 함수 리터럴이 컴파일 될 때 함수가 객체로 래핑되어서 발생하는 문제이다. 함수가 다른 클래스에 위치하므로 return을 사용해 main으로 돌아올 수 없는 것이다.</p>\n<p>아래처럼 inline 함수는 이런 제한이 없다. 함수가 main 내부에 들어가기 때문이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">fun main() {\n    repeat(10) {\n        print(it)\n        return\n    }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"inline-한정자의-비용\" style=\"position:relative;\"><a href=\"#inline-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EB%B9%84%EC%9A%A9\" aria-label=\"inline 한정자의 비용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>inline 한정자의 비용</h2>\n<p>inline은 유용하지만 모든 곳에 사용할 수는 없다.</p>\n<ul>\n<li>\n<p>재귀적으로 동작할 수 없다.</p>\n<p>재귀적으로 사용하면 무한하게 대체되는 문제가 발생한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun a() { b() }\ninline fun b() { c() }\ninline fun c() { a() }</code>\n        </deckgo-highlight-code>\n</li>\n<li>더 많은 가시성 제한을 가진 요소를 사용할 수 없다.(인라인 함수 내부에서 private , internal 가시성을 가진 함수와 프로퍼티를 사용할 수 없음)</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">internal inline fun read() {\n    val reader = Reader() // 오류\n}\n\nprivate class Reader {\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>구현을 숨길 수 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun printTree() {\n    print(3)\n}\n\ninline fun threePrintThree() {\n    printTree()\n    printTree()\n    printTree()\n}\n\ninline fun threeThreePrintThree() {\n    threePrintThree()\n    threePrintThree()\n    threePrintThree()\n}</code>\n        </deckgo-highlight-code>\n<p>위 코드는 아래와 같이 컴파일 된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\"  >\n          <code slot=\"code\">inline fun printTree() {\n    print(3)\n}\n\ninline fun threePrintThree() {\n    print(3)\n    print(3)\n    print(3)\n}\n\ninline fun threeThreePrintThree() {\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n    print(3)\n}</code>\n        </deckgo-highlight-code>\n<p>inline 한정자를 남용하면 코드의 크기가 쉽게 커진다. 서로 호출하는 인라인 함수가 많아지면, 코드가 기하급수적으로 증가하므로 위험하다.</p>\n</li>\n</ul>\n<h2 id=\"crossinline과-noinline\" style=\"position:relative;\"><a href=\"#crossinline%EA%B3%BC-noinline\" aria-label=\"crossinline과 noinline permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>crossinline과 noinline</h2>\n<p>함수를 인라인으로 만들고 싶지만 어떤 이유로 일부 함수 타입 파라미터는 inline으로 받고 싶지 않은 경우에 다음과 같은 한정자를 사용한다.</p>\n<ul>\n<li>\n<p>crossinline</p>\n<ul>\n<li>아규먼트로 인라인 함수를 받지만, 비지역적 리턴을 하는 함수는 받을 수 없게 만든다. 인라인으로 만들지 않은 다른 람다 표현식과 조합해서 사용할 때 문제가 발생하는 경우 활용</li>\n</ul>\n</li>\n<li>\n<p>noineline</p>\n<ul>\n<li>아규먼트로 인라인 함수를 받을 수 없게 만든다. 인라인 함수가 아닌 함수를 아규먼트로 사용하고 싶을 때 활용</li>\n</ul>\n</li>\n</ul>\n<p>두가지 한정자의 의미를 기억하면 좋겠지만 인텔리제이에서 필요할 때 제안하므로 대충 알아두어도 괜찮다고 책에 기술되어 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>인라인 함수가 사용되는 주요 사례</p>\n<ul>\n<li>print 처럼 매우 많이 사용되는 경우</li>\n<li>filterIsInstance 함수처럼 타입 아규먼트로 reified 타입을 전달받는 경우</li>\n<li>함수 타입 파라미터를 갖는 톱레벨 함수를 정의해야 하는 경우, 컬렉션 처리와 같은 헬퍼(map, filter, flatMap), 스코프 함수(also, apply, let), 톱레벨 유틸리티 함수(epeat, run, with)</li>\n</ul>\n<p>인라인 함수가 다른 인라인 함수를 호출하면 코드가 기하급수적으로 많아질 수 있으므로 주의하자.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#%ED%83%80%EC%9E%85-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-reified%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">타입 아규먼트를 reified로 사용할 수 있다.</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A7%84-%ED%95%A8%EC%88%98%EA%B0%80-%ED%9B%A8%EC%94%AC-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%9C%EB%8B%A4\">함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#%EB%B9%84%EC%A7%80%EC%97%AD%EC%A0%81-%EB%A6%AC%ED%84%B4non-local-return%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">비지역적 리턴(non-local return)을 사용할 수 있다.</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#inline-%ED%95%9C%EC%A0%95%EC%9E%90%EC%9D%98-%EB%B9%84%EC%9A%A9\">inline 한정자의 비용</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#crossinline%EA%B3%BC-noinline\">crossinline과 noinline</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-46/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-46","tagSlugs":null},"frontmatter":{"date":"2022-03-26T00:15:00.000Z","description":"Effective Kotlin Item 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라","tags":null,"title":"이펙티브 코틀린 아이템 46. 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-46"}},"staticQueryHashes":["2067870509","251939775","401334301"]}