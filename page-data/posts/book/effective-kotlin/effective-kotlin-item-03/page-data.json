{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/book/effective-kotlin/effective-kotlin-item-03","result":{"data":{"markdownRemark":{"id":"b0798c8a-f906-5e4b-96a0-8c601f9d2665","html":"<p>자바에서 자주 볼 수 있었던 NPE는 코틀린의 null-safety 메커니즘으로 인해 거의 찾아보기 힘들지만 자바와 코틀린을 연결해서 사용할 때는 이러한 예외가 발생할 수 있다.</p>\n<p><code class=\"language-text\">@NotNull</code> 혹은 <code class=\"language-text\">@Nullable</code> 이 붙은 경우라면 String, String?으로 추정 및 변경이 가능하지만 <strong>어노테이션이 없다면 모든 것을 nullable로 가정</strong>하고 다루어야 한다.</p>\n<p>nullable과 가장 많은 문제가 되는 부분은 자바의 제네릭 타입이다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">public class UserRepo {\n    public List&lt;User&gt; getUsers() {\n        // **\n    }\n}\n\nval users: List&lt;User&gt; = UserRepo().users!!.filterNotNull()</code>\n        </deckgo-highlight-code>\n<p>위와 같이 리스트 자체가 null인지, 내부 데이터가 널인지 등을 체크해야 하며 리스트가 아닌 map, filterNotNull 등의 메소드를 제공하지 않는 다른 제네릭 타입이라면 null 확인 자체가 복잡한 일이 된다.</p>\n<h3 id=\"플랫폼-타입\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85\" aria-label=\"플랫폼 타입 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>플랫폼 타입</strong></h3>\n<p>위와 같은 문제 때문에 코틀린은 자바 등 다른 프로그래밍 언어에서 넘어온 타입을 특수하게 다루며 이를 <strong>플랫폼 타입(platform type)</strong>이라고 부른다.\n플랫폼 타입은 String! 처럼 뒤에 ! 기호를 붙여서 표기한다. (직접적으로 코드에 나타나지는 않음)</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">val repo = UserRepo()\nval user1 = repo.user // user1: User!\nval user2: User = repo.user // user2: User\nval user1: User? = repo.user // user3: User?</code>\n        </deckgo-highlight-code>\n<p>위와 같이 사용이 가능하기 때문에 null 체크 등의 복잡한 문제는 사라진다.</p>\n<p>하지만 여전히 null일 가능성이 존재하므로 플랫폼 타입을 사용할 때는 항상 주의를 기울여야 한다.</p>\n<p>가급적 자바를 코틀린과 함께 사용할 때 자바 코드에 아래와 같이 어노테이션(NotNull, Nullable)을 붙여 사용하자.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">public @NotNull User getUser() {\n}</code>\n        </deckgo-highlight-code>\n<p>현재 다음과 같은 어노테이션이 지원되고 있음</p>\n<ul>\n<li>org.jetbrains.annotations <code class=\"language-text\">@Nullable</code> <code class=\"language-text\">@NotNull</code></li>\n<li>JSR-305, javax.annotation <code class=\"language-text\">@Nullable</code> <code class=\"language-text\">@Nonnull</code>, <code class=\"language-text\">@CheckForNull</code></li>\n<li>JavaX, javax.annotation <code class=\"language-text\">@Nullable</code> <code class=\"language-text\">@Nonnull</code>, <code class=\"language-text\">@CheckForNull</code></li>\n<li>기타 등등</li>\n</ul>\n<p>JSR-305의 <code class=\"language-text\">@ParametersAreNonnullbyDefault</code> 를 사용하면 자바에서도 디폴트로 파라미터가 널이 아님을 보장할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">public class JavaClass {\n    public String getValue() {\n        return null;\n    }\n}\n\nfun statedType() {\n    // NPE\n    val value: String = JavaClass().value\n\n    println(value.length)\n}\n\nfun platformType() {\n    val value = JavaClass().value\n\n    // NPE\n    println(value.length)\n}</code>\n        </deckgo-highlight-code>\n<p>위 케이스에서 statedType은 값을 가져오는 경우에 즉시 NPE가 발생하지만 platformType은 length를 호출할 때 NPE가 발생한다.</p>\n<p>이러한 변수를 한 두번 안전하게 사용하더라도 이후에 다른 사람이 사용할 때 NPE가 발생하지 않은거란 보장이 없음 때문에 이와 같은 <strong>플랫폼 타입은 최대한 빨리 제거</strong>하는 것이 좋다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">interface UserRepo {\n    fun getUserName() = JavaClass().value\n}\n\nclass RepoImpl: UserRepo {\n    override fun getUserName(): String? {\n        return null\n    }\n}\n\nfun main() {\n    val repo: UserRepo = RepoImpl()\n    val text: String = repo.getUserName() // Runtime에 NPE\n}</code>\n        </deckgo-highlight-code>\n<p>위의 예제에서도 디폴트 메소드가 inferred type(추론된 타입)이며 플랫폼 타입으로 지정되기 때문에 사용하는 사람이 nullable이 아닐거라고 받아들이면 런타임에 NPE가 발생할 수 있다.</p>\n<blockquote>\n<p>위와 같은 문제를 IDE에서 친절하게 알려주긴 합니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2567854fee0a640b5bb1145faa9019f8/75d3b/inferred-type-ide.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.833333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsSAAALEgHS3X78AAAAgElEQVQI10XIyQrCMABF0X6JoChCh5gmndJZoTZFV2JL/f8PudZsXBy473lZ/kZ2M/K6IPsF1czE+omuV1T9Iam2v3wR9CtCTYh4JHLs1n+/7YsBb7dXnM45dfugqCymmiiM3YzkxZ00GzClJdE3/LAhunQEUUMoWteO6Nw+HFO+SOlCrE+wVE8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/2567854fee0a640b5bb1145faa9019f8/8ac56/inferred-type-ide.webp 240w,\n/static/2567854fee0a640b5bb1145faa9019f8/d3be9/inferred-type-ide.webp 480w,\n/static/2567854fee0a640b5bb1145faa9019f8/e46b2/inferred-type-ide.webp 960w,\n/static/2567854fee0a640b5bb1145faa9019f8/f992d/inferred-type-ide.webp 1440w,\n/static/2567854fee0a640b5bb1145faa9019f8/882b9/inferred-type-ide.webp 1920w,\n/static/2567854fee0a640b5bb1145faa9019f8/ee81e/inferred-type-ide.webp 1966w\"\n          sizes=\"(max-width: 960px) 100vw, 960px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/2567854fee0a640b5bb1145faa9019f8/8ff5a/inferred-type-ide.png 240w,\n/static/2567854fee0a640b5bb1145faa9019f8/e85cb/inferred-type-ide.png 480w,\n/static/2567854fee0a640b5bb1145faa9019f8/d9199/inferred-type-ide.png 960w,\n/static/2567854fee0a640b5bb1145faa9019f8/07a9c/inferred-type-ide.png 1440w,\n/static/2567854fee0a640b5bb1145faa9019f8/29114/inferred-type-ide.png 1920w,\n/static/2567854fee0a640b5bb1145faa9019f8/75d3b/inferred-type-ide.png 1966w\"\n          sizes=\"(max-width: 960px) 100vw, 960px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/2567854fee0a640b5bb1145faa9019f8/d9199/inferred-type-ide.png\"\n          alt=\"inferred-type-ide\"\n          title=\"inferred-type-ide\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></p>\n</blockquote>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<ul>\n<li>다른 프로그래밍 언어에서 와서 nullable 여부를 알 수 없는 값을 플랫폼 타입이라고 한다.</li>\n<li>사용하는 부분 뿐만 아니라 활용하는 곳 까지 영향을 줄 수 있는 위험한 코드이며 빨리 해당 코드를 제거하는게 좋다.</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>이펙티브 코틀린 - 프로그래밍 인사이트, 마르친 모스칼라 지음, 윤인성 옮김</li>\n</ul>\n<p>개인적인 기록을 위해 작성된 글이라 잘못된 내용이 있을 수 있습니다.</p>\n<p>오류가 있다면 댓글을 남겨주세요.</p>","tableOfContents":"<ul>\n<li>\n<ul>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-03/#%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85\"><strong>플랫폼 타입</strong></a></li>\n</ul>\n</li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-03/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n<li><a href=\"/posts/book/effective-kotlin/effective-kotlin-item-03/#reference\">Reference</a></li>\n</ul>","fields":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-03","tagSlugs":null},"frontmatter":{"date":"2022-02-08T00:40:00.000Z","description":"Effective Kotlin Item 03. 최대한 플랫폼 타입을 사용하지 말라","tags":null,"title":"이펙티브 코틀린 아이템 03. 최대한 플랫폼 타입을 사용하지 말라","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/book/effective-kotlin/effective-kotlin-item-03"}},"staticQueryHashes":["2067870509","251939775","401334301"]}