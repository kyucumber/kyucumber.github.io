{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/spring/spring-with-async-and-thread-pool-task-executor/","result":{"data":{"markdownRemark":{"id":"e93d3b4a-2ba3-5b21-ba65-4e32c7036070","html":"<p>스프링에서 Async를 사용하는 경우 <code class=\"language-text\">@EnableAsync</code> 어노테이션의 주석에서 아래와 같은 내용을 확인할 수 있습니다.</p>\n<deckgo-highlight-code language=\"kotlin\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">By default, Spring will be searching for an associated thread pool definition: \neither a unique org.springframework.core.task.TaskExecutor bean in the context,\nor an java.util.concurrent.Executor bean named &quot;taskExecutor&quot; otherwise.\nIf neither of the two is resolvable, a org.springframework.core.task.SimpleAsyncTaskExecutor will be used to process async method invocations.\nBesides, annotated methods having a void return type cannot transmit any exception back to the caller.\nBy default, such uncaught exceptions are only logged.\n\nTo customize all this, implement AsyncConfigurer and provide:</code>\n        </deckgo-highlight-code>\n<p>TaskExecutor를 구현한 빈을 찾지 못하면 <code class=\"language-text\">SimpleAsyncTaskExecutor</code>를 사용한다고 되어 있습니다.</p>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">// NOTE: This implementation does not reuse threads! Consider a thread-pooling TaskExecutor implementation instead, in particular for executing a large number of short-lived tasks.\n\npublic class SimpleAsyncTaskExecutor extends CustomizableThreadCreator\n\t\timplements AsyncListenableTaskExecutor, Serializable {\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">SimpleAsyncTaskExecutor</code> 클래스에는 스레드를 재사용하지 않는다고 적혀있어 해당 Executor를\n사용하면 문제가 될 것 같은데 실제로 아무런 설정을 넣지 않아도 <code class=\"language-text\">SimpleAsyncTaskExecutor</code>를 사용하지 않습니다.</p>\n<p>이는 <code class=\"language-text\">TaskExecutionAutoConfiguration</code>에 의해 <code class=\"language-text\">ThreadPoolTaskExecutor</code>가 생성되기 때문입니다.\n<code class=\"language-text\">spring.factories</code>에 아래와 같은 내용이 등록되어 있습니다.</p>\n<deckgo-highlight-code   terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\"  terminal=\"carbon\" theme=\"one-light\" >\n          <code slot=\"code\">@ConditionalOnClass(ThreadPoolTaskExecutor.class)\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(TaskExecutionProperties.class)\npublic class TaskExecutionAutoConfiguration {\n\n\t/**\n\t * Bean name of the application {@link TaskExecutor}.\n\t */\n\tpublic static final String APPLICATION_TASK_EXECUTOR_BEAN_NAME = &quot;applicationTaskExecutor&quot;;\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic TaskExecutorBuilder taskExecutorBuilder(TaskExecutionProperties properties,\n\t\t\tObjectProvider&lt;TaskExecutorCustomizer&gt; taskExecutorCustomizers,\n\t\t\tObjectProvider&lt;TaskDecorator&gt; taskDecorator) {\n\t\tTaskExecutionProperties.Pool pool = properties.getPool();\n\t\tTaskExecutorBuilder builder = new TaskExecutorBuilder();\n\t\tbuilder = builder.queueCapacity(pool.getQueueCapacity());\n\t\tbuilder = builder.corePoolSize(pool.getCoreSize());\n\t\tbuilder = builder.maxPoolSize(pool.getMaxSize());\n\t\tbuilder = builder.allowCoreThreadTimeOut(pool.isAllowCoreThreadTimeout());\n\t\tbuilder = builder.keepAlive(pool.getKeepAlive());\n\t\tShutdown shutdown = properties.getShutdown();\n\t\tbuilder = builder.awaitTermination(shutdown.isAwaitTermination());\n\t\tbuilder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());\n\t\tbuilder = builder.threadNamePrefix(properties.getThreadNamePrefix());\n\t\tbuilder = builder.customizers(taskExecutorCustomizers.orderedStream()::iterator);\n\t\tbuilder = builder.taskDecorator(taskDecorator.getIfUnique());\n\t\treturn builder;\n\t}\n\n\t@Lazy\n\t@Bean(name = { APPLICATION_TASK_EXECUTOR_BEAN_NAME,\n\t\t\tAsyncAnnotationBeanPostProcessor.DEFAULT_TASK_EXECUTOR_BEAN_NAME })\n\t@ConditionalOnMissingBean(Executor.class)\n\tpublic ThreadPoolTaskExecutor applicationTaskExecutor(TaskExecutorBuilder builder) {\n\t\treturn builder.build();\n\t}\n\n}</code>\n        </deckgo-highlight-code>\n<p>기본적으로 생성되는 <code class=\"language-text\">ThreadPoolTaskExecutor</code>는 Async 이외에 다른 스케줄링에도 사용되므로 <code class=\"language-text\">@Async</code> 사용 시 <code class=\"language-text\">AsyncConfigurerSupport</code>를 통해 비동기 작업을 위한 스레드풀을 별도로 정의해주는게 좋습니다.</p>","tableOfContents":"","fields":{"slug":"/posts/spring/spring-with-async-and-thread-pool-task-executor/","tagSlugs":["/tag/spring/","/tag/async/","/tag/thread-pool-task-executor/"]},"frontmatter":{"date":"2020-11-08T00:00:00.000Z","description":"스프링과 Async, ThreadPoolTaskExecutor","tags":["Spring","Async","ThreadPoolTaskExecutor"],"title":"스프링과 Async, ThreadPoolTaskExecutor","socialImage":{"publicURL":"/static/3fb2d4de4502fbae8b21ee45fe945cf4/kyucumber.jpg"}}}},"pageContext":{"slug":"/posts/spring/spring-with-async-and-thread-pool-task-executor/"}},"staticQueryHashes":["2067870509","251939775","401334301"]}